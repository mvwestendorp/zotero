<?xml version="1.0"?>
<!--
    ***** BEGIN LICENSE BLOCK *****
    
    Copyright Â© 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org
    
    This file is part of Zotero.
    
    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.
    
    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.
    
    ***** END LICENSE BLOCK *****
-->

<!DOCTYPE bindings SYSTEM "chrome://zotero/locale/zotero.dtd">
<!-- <!DOCTYPE bindings SYSTEM "chrome://zotero/locale/itembox.dtd"> -->

<bindings xmlns="http://www.mozilla.org/xbl"
		  xmlns:xbl="http://www.mozilla.org/xbl"
		  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	
	<binding id="item-box">
		<resources>
			<stylesheet src="chrome://zotero/skin/bindings/itembox.css"/>
			<stylesheet src="chrome://zotero-platform/content/itembox.css"/>
		</resources>
		
		<implementation>
			<!--
				Public properties
			-->
			<field name="clickable">false</field>
			<field name="editable">false</field>
			<field name="saveOnEdit">false</field>
			<field name="showTypeMenu">false</field>
			<field name="hideEmptyFields">false</field>
			<field name="clickByRow">false</field> <!-- Click entire row rather than just field value -->
			<field name="clickByItem">false</field>
			
			<field name="clickHandler"/>
			<field name="blurHandler"/>
			<field name="eventHandlers">[]</field>
			
			<field name="_initialVisibleCreators">5</field>
			<field name="_displayAllCreators"/>
			
			<!-- Modes are predefined settings groups for particular tasks -->
			<field name="_mode">"view"</field>
			<property name="mode" onget="return this._mode;">
				<setter>
				<![CDATA[
					this.clickable = false;
					this.editable = false;
					this.saveOnEdit = false;
					this.showTypeMenu = false;
					this.hideEmptyFields = false;
					this.clickByRow = false;
					this.clickByItem = false;
					
					switch (val) {
						case 'view':
						case 'merge':
							break;
						
						case 'edit':
							this.clickable = true;
							this.editable = true;
							this.saveOnEdit = true
							this.showTypeMenu = true;
							this.clickHandler = this.showEditor;
							this.blurHandler = this.hideEditor;
							break;
						
						case 'fieldmerge':
							this.hideEmptyFields = true;
							this._fieldAlternatives = {};
							break;
						
						default:
							throw ("Invalid mode '" + val + "' in itembox.xml");
					}
					
					this._mode = val;
					document.getAnonymousNodes(this)[0].setAttribute('mode', val);
				]]>
				</setter>
			</property>
			
			<field name="_item"/>
			<property name="item" onget="return this._item;">
				<setter><![CDATA[
					if (!(val instanceof Zotero.Item)) {
						throw new Error("'item' must be a Zotero.Item");
					}
					if (this._suppressRefresh) {
						this._suppressRefresh = false;
						return;
					}
					
					// When changing items, reset truncation of creator list
					if (!this._item || val.id != this._item.id) {
						this._displayAllCreators = false;
					}
					
					if (this._item && val.id == this._item.id) {
						this._item = val;
						this.refresh(true);
					} else {
						this._item = val;
						this.refresh();
					}
				]]></setter>
			</property>
			
			<!-- .ref is an alias for .item -->
			<property name="ref"
				onget="return this._item;"
				onset="this.item = val; this.refresh();">
			</property>
			
			
			<!--
				 An array of field names that should be shown
				 even if they're empty and hideEmptyFields is set
			-->
			<field name="_visibleFields">[]</field>
			<property name="visibleFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('visibleFields must be an array in <itembox>.visibleFields');
					}
					
					this._visibleFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names that should be hidden
			-->
			<field name="_hiddenFields">[]</field>
			<property name="hiddenFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('hiddenFields must be an array in <itembox>.visibleFields');
					}
					
					this._hiddenFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names that should be clickable
				 even if this.clickable is false
			-->
			<field name="_clickableFields">[]</field>
			<property name="clickableFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('clickableFields must be an array in <itembox>.clickableFields');
					}
					
					this._clickableFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names that should be editable
				 even if this.editable is false
			-->
			<field name="_editableFields">[]</field>
			<property name="editableFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('editableFields must be an array in <itembox>.editableFields');
					}
					
					this._editableFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An object of alternative values for keyed fields
				 
			-->
			<field name="_fieldAlternatives">{}</field>
			<property name="fieldAlternatives">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Object') {
						throw ('fieldAlternatives must be an Object in <itembox>.fieldAlternatives');
					}
					
					if (this.mode != 'fieldmerge') {
						throw ('fieldAlternatives is valid only in fieldmerge mode in <itembox>.fieldAlternatives');
					}
					
					this._fieldAlternatives = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names in the order they should appear
				 in the list; empty spaces can be created with null
			-->
			<field name="_fieldOrder">[]</field>
			<property name="fieldOrder">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('fieldOrder must be an array in <itembox>.fieldOrder');
					}
					
					this._fieldOrder = val;
				]]>
				</setter>
			</property>
			
			<property name="itemTypeMenu" onget="return this._id('item-type-menu')"/>
			
			<!-- Private properties -->
			<property name="_dynamicFields" onget="return this._id('dynamic-fields')"/>
			<property name="_creatorTypeMenu" onget="return this._id('creator-type-menu')"/>
			<property name="_nameParticlesMenu" onget="return this._id('name-particles-menu')"/>
			
			<field name="_selectField"/>
			<field name="_beforeRow"/>
			<field name="_addCreatorRow"/>
			<field name="_creatorCount"/>
			
			<field name="_lastTabIndex"/>
			<field name="_tabDirection"/>
			<field name="_tabIndexMinPrefields" readonly="true">1</field>
			<field name="_tabIndexMaxPrefields">0</field>
			<field name="_tabIndexMinCreators" readonly="true">100</field>
			<field name="_tabIndexMaxCreators">0</field>
			<field name="_tabIndexMinFields" readonly="true">10000</field>
			<field name="_tabIndexMaxFields">0</field>
			
			<property name="_defaultFirstName"
				onget="return '(' + Zotero.getString('pane.item.defaultFirstName') + ')'"/>
			<property name="_defaultLastName"
				onget="return '(' + Zotero.getString('pane.item.defaultLastName') + ')'"/>
			<property name="_defaultFullName"
				onget="return '(' + Zotero.getString('pane.item.defaultFullName') + ')'"/>
			
			<constructor>
			<![CDATA[
				this._notifierID = Zotero.Notifier.registerObserver(this, ['item'], 'itembox');
			]]>
			</constructor>
			
			<destructor>
			<![CDATA[
				Zotero.Notifier.unregisterObserver(this._notifierID);
			]]>
			</destructor>
			
			<method name="notify">
				<parameter name="event"/>
				<parameter name="type"/>
				<parameter name="ids"/>
				<body><![CDATA[
					if (event != 'modify' || !this.item || !this.item.id) return;
					for (let i = 0; i < ids.length; i++) {
						let id = ids[i];
						if (id != this.item.id) {
							continue;
						}
						this.refresh();
						break;
					}
				]]></body>
			</method>
			
						
			<method name="multiTabUpdate">
				<body>
				<![CDATA[
					var nodes = document.evaluate('*//*[@ztabindex]', this._dynamicFields, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
					var creatorSeen = false;
					var fieldSeen = false;
					var count = 1;
					for (var i=0,ilen=nodes.snapshotLength;i<ilen;i++) {
						var node = nodes.snapshotItem(i);
						var fieldName = node.getAttribute('fieldname');
						var isCreator = !!fieldName.match(/^creator-/);
						if (!creatorSeen && isCreator) {
							this._tabIndexMaxPrefields = count;
							count = 100;
							creatorSeen = true;
						}
						if (creatorSeen && !fieldSeen && !isCreator) {
							this._tabIndexMaxCreators = count;
							count = 10001;
							fieldSeen = true;
						}
						var tabindex = parseInt(node.getAttribute('ztabindex'),10);
						if (tabindex > -1) {
							node.setAttribute("ztabindex", count);
						}
						count++;
					}
					this._tabIndexMaxFields = count;
				]]>
				</body>
			</method>
			
			<method name="creatorMainLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="creator"/>
				<body>
				<![CDATA[
					var creator = Zotero.Creators.cleanData(creator, true);
					var fieldName = node.getAttribute('fieldname');
					var [field, creatorIndex, creatorField] = fieldName.split('-');
					var creatorTypeID = creator.creatorTypeID;
					if (creator.multi._key[tag]) {
						// If a matching value exists, swap them
						var mainTag = creator.multi.main;
						var mainFields = Zotero.Creators.cleanData(creator);
						var variantTag = tag;
						var variantFields = Zotero.Creators.cleanData(creator.multi._key[variantTag]);
						creator.multi.main = variantTag;
						Object.assign(creator, variantFields);
                        creator.multi._key[mainTag] = mainFields;
						delete creator.multi._key[variantTag];
						this.item.setCreator(creatorIndex, creator, creatorTypeID);
						this.item.saveTx();
					} else {
						// If no matching value exists, just update and save
						creator.multi.main = tag;
						this.item.setCreator(creatorIndex, creator, creatorTypeID);
						this.item.saveTx();
					}
				]]>
				</body>
			</method>
			
			<method name="creatorAddLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="fieldValue"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					var creatorIndex = parseInt(fieldName.split('-')[1],10);
					var mainCreator = this.item.getCreator(creatorIndex);
					var creatorTypeID = mainCreator.creatorTypeID;
					var langNickname = Zotero.CachedLanguages.getNickname(tag);
					var fields = {
						lastName: mainCreator.lastName,
						firstName: mainCreator.firstName,
						fieldMode: mainCreator.fieldMode
					}
					var row = Zotero.getAncestorByTagName(node,'row');
					var parent = row.parentNode;
					var sibling = row.nextSibling;
					if (!sibling || 'rows' !== sibling.tagName || !sibling.classList.contains('multi')) {
						var rows = document.createElement('rows');
						rows.classList.add('multi')
						parent.insertBefore(rows,sibling)
						if (!row.nextSibling || !row.nextSibling.classList.contains('multi')) {
							parent.insertBefore(rows, sibling);
						}
					} else {
						var rows = sibling;
					}
					this.addCreatorRow(fields, creatorTypeID, true, null, rows, null, tag);
				]]>
				</body>
			</method>
			
			<method name="creatorChangeLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="creator"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					var creatorIndex = parseInt(fieldName.split('-')[1],10);
					var oldTag = node.getAttribute("zlang");
					creator.multi.changeLangTag(oldTag, tag);
					if (!this.item._changedAltCreators) {
						this.item._changedAltCreators = {};
					}
					if (!this.item._changedAltCreators[creatorIndex]) {
						this.item._changedAltCreators[creatorIndex] = {};
					}
					this.item._changedAltCreators[creatorIndex][oldTag] = true;
					this.item._changedAltCreators[creatorIndex][tag] = true;
					this.item.saveTx();
				]]>
				</body>
			</method>
			
			<method name="mainLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="fieldValue"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					// XXX Check for existing target tag among variants.
					if (this.item.multi.hasLang(tag, fieldName)) {
						// XXX If a matching variant exists, get the row and its values.
						var variantNickname = Zotero.CachedLanguages.getNickname(tag);
						var variantValue = this.item.getField(fieldName, null, null, tag);
						var row = null;
						var parentRow = Zotero.getAncestorByTagName(node, 'row');
						var rows = parentRow.nextSibling;
						if (rows.tagName === 'rows' && rows.classList.contains('multi')) {
							for (var i=0,ilen=rows.childNodes.length;i<ilen;i++) {
								var lang = rows.childNodes[i].firstChild.getAttribute('zlang');
								if (lang === tag) {
									row = rows.childNodes[i];
									break;
								}
							}
							// XXX Also get the values of main.
							var mainLang = this.item.multi.mainLang(fieldName);
							var mainValue = this.item.getField(fieldName);
							
							this.item.multi.changeLangTag(mainLang, tag, fieldName);
							this.item.saveTx();
							this.refresh();
						}
					} else {
						// XXX If no matching value exists, just adjust the UI as below.
						var fieldName = node.getAttribute('fieldname');
						var langNickname = Zotero.CachedLanguages.getNickname(tag);
						node.setAttribute('zlang',tag);
						node.setAttribute('tooltiptext',langNickname);
						this._modifyField(fieldName,fieldValue,tag,true);
					}
				]]>
				</body>
			</method>
			
			<method name="addLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="fieldValue"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					var langNickname = Zotero.CachedLanguages.getNickname(tag);

					// Add rows sibling if necessary
					var row = Zotero.getAncestorByTagName(node,'row');
					var rows = row.nextSibling;
					if ('rows' !== rows.tagName || !rows.classList.contains('multi')) {
						rows = document.createElement('rows');
						rows.classList.add('multi')
						row.parentNode.insertBefore(rows,row.nextSibling)
					}
					this._selectField = fieldName;
					this.addFieldRow(999999,fieldName, fieldValue, rows, null, tag);
				]]>
				</body>
			</method>
			
			<method name="changeLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="fieldValue"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					var langNickname = Zotero.CachedLanguages.getNickname(tag);
					var oldTag = node.getAttribute("zlang");
					node.setAttribute('zlang',tag);
					node.setAttribute('tooltiptext',langNickname);
					node.setAttribute('value',langNickname);
					//this._modifyField(fieldName,fieldValue,true,tag);
					this.item.multi.changeLangTag(oldTag, tag, fieldName);
					this.item.saveTx();
				]]>
				</body>
			</method>
			
			<method name="addFieldRow">
				<parameter name="tabindexValue"/>
				<parameter name="fieldName"/>
				<parameter name="fieldValue"/>
				<parameter name="parentNode"/>
				<parameter name="nextNode"/>
				<parameter name="langTag"/>
				<body>
				<![CDATA[
					var val = '';
					
					var isMulti = false;
					if (parentNode && parentNode.classList.contains('multi')) {
						isMulti = true;
					}
					
					if (fieldName) {
						var fieldID = Zotero.ItemFields.getID(fieldName);
						if (fieldID && !Zotero.ItemFields.isValidForType(fieldID, this.item.itemTypeID)) {
							fieldName = null;
						}
					}
					
					if (fieldName) {
						if (this._hiddenFields.indexOf(fieldName) != -1) {
							return;
						}
						
						// createValueElement() adds the itemTypeID as an attribute
						// and converts it to a localized string for display
						if (fieldName == 'itemType') {
							val = this.item.itemTypeID;
						}
						else if (fieldValue) {
							val = fieldValue;
						}
						else {
							val = this.item.getField(fieldName);
						}
						
						if (!val && this.hideEmptyFields
								&& this._visibleFields.indexOf(fieldName) == -1
								&& (this.mode != 'fieldmerge' || typeof this._fieldAlternatives[fieldName] == 'undefined')) {
							return;
						}
						
						var fieldIsClickable = this._fieldIsClickable(fieldName);
						
						// Start tabindex at 10001 after creators
						var tabindex = fieldIsClickable ? tabindexValue : 0;
						this._tabIndexMaxFields = Math.max(this._tabIndexMaxFields, tabindex);
						
						if (fieldIsClickable
								&& !Zotero.Items.isPrimaryField(fieldName)
								&& (Zotero.ItemFields.isFieldOfBase(Zotero.ItemFields.getID(fieldName), 'date')
									// TEMP - filingDate
									|| Zotero.Utilities.isDate(fieldName))
								// TEMP - NSF
								&& fieldName != 'dateSent') {
							this.addDateRow(fieldName, this.item.getField(fieldName, true), tabindex);
							return;
						}
					}

					let label = document.createElement("label");
					label.setAttribute('fieldname', fieldName);
					
					let valueElement = this.createValueElement(
						val, fieldName, tabindex, !!parentNode
					);
					
					if (Zotero.CachedMultiFields.isMultiFieldName(fieldName)) {
						var fieldLang = langTag;
						if (!fieldLang) {
							fieldLang = this.item.multi.mainLang(fieldName);
					   }
						if (fieldLang) {
							label.setAttribute('zlang',fieldLang);
							var langNickname = Zotero.CachedLanguages.getNickname(fieldLang);
							label.setAttribute('tooltiptext',langNickname);
						}
						if (this.editable) {
							if (parentNode || Zotero.CachedLanguages.getLanguageList().length) {
								label.classList.add('zotero-alien-clicky');
							}
						}
					}
					
					var prefix = '';
					// Add '(...)' before 'Abstract' for collapsed abstracts
					if (fieldName == 'abstractNote') {
						if (val && !Zotero.Prefs.get('lastAbstractExpand')) {
							prefix = '(\u2026) ';
						}
					}
					
					if (fieldName) {
						if (isMulti && langTag) {
							var variantName = Zotero.CachedLanguages.getNickname(langTag);
							label.setAttribute("value", variantName);
						} else {
							label.setAttribute("value", prefix +
								Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, fieldName));
						}
					}
					
					// TEMP - NSF (homepage)
					if ((fieldName == 'url' || fieldName == 'homepage') && val) {
						label.classList.add("pointer");
						// TODO: make getFieldValue non-private and use below instead
						label.setAttribute("onclick", "ZoteroPane_Local.loadURI(this.nextSibling.firstChild ? this.nextSibling.firstChild.nodeValue : this.nextSibling.value, event)");
						label.setAttribute("tooltiptext", Zotero.getString('locate.online.tooltip'));
					}
					else if (fieldName == 'DOI' && val && typeof val == 'string') {
						// Pull out DOI, in case there's a prefix
						var doi = Zotero.Utilities.cleanDOI(val);
						if (doi) {
							doi = "http://dx.doi.org/" + encodeURIComponent(doi);
							label.classList.add("pointer");
							label.setAttribute("onclick", "ZoteroPane_Local.loadURI('" + doi + "', event)");
							label.setAttribute("tooltiptext", Zotero.getString('locate.online.tooltip'));
							valueElement.setAttribute('contextmenu', 'zotero-doi-menu');
							
							var openURLMenuItem = document.getElementById('zotero-doi-menu-view-online');
							openURLMenuItem.setAttribute("oncommand", "ZoteroPane_Local.loadURI('" + doi + "', event)");
							
							var copyMenuItem = document.getElementById('zotero-doi-menu-copy');
							copyMenuItem.setAttribute("oncommand", "Zotero.Utilities.Internal.copyTextToClipboard('" + doi + "')");
						}
					}
					else if (fieldName == 'abstractNote') {
						if (val.length) {
							label.classList.add("pointer");
						}
						label.addEventListener('click', function () {
							if (this.nextSibling.inputField) {
								this.nextSibling.inputField.blur();
							}
							else {
								document.getBindingParent(this).toggleAbstractExpand(
									this, this.nextSibling
								);
							}
						});
					}
					else {
						label.setAttribute("onclick",
							"if (this.nextSibling.inputField) { this.nextSibling.inputField.blur(); }");
						label.setAttribute("contextmenu", "mlz-language-menu");
					}
					
					var row = this.addDynamicRow(label, valueElement, null, null, parentNode, nextNode);
					if (parentNode) {
						this.multiTabUpdate();
					}
					if (fieldName && this._selectField == fieldName) {
						this.showEditor(valueElement);
						// Not in official Zotero
						this._selectField = false;
					}
					
					// In field merge mode, add a button to switchfield versions
					else if (this.mode == 'fieldmerge' && typeof this._fieldAlternatives[fieldName] != 'undefined') {
						var button = document.createElement("toolbarbutton");
						button.className = 'zotero-field-version-button';
						button.setAttribute('image', 'chrome://zotero/skin/treesource-duplicates.png');
						button.setAttribute('type', 'menu');
						
						var popup = button.appendChild(document.createElement("menupopup"));
						
						for (let v of this._fieldAlternatives[fieldName]) {
							var menuitem = document.createElement("menuitem");
							var sv = Zotero.Utilities.ellipsize(v, 60);
							menuitem.setAttribute('label', sv);
							if (v != sv) {
								menuitem.setAttribute('tooltiptext', v);
							}
							menuitem.setAttribute('fieldName', fieldName);
							menuitem.setAttribute('originalValue', v);
							menuitem.setAttribute(
								'oncommand',
								"var binding = document.getBindingParent(this); "
								+ "var item = binding.item; "
								+ "item.setField(this.getAttribute('fieldName'), this.getAttribute('originalValue')); "
								+ "var row = Zotero.getAncestorByTagName(this, 'row'); "
								+ "binding.refresh();"
							);
							popup.appendChild(menuitem);
						}
						
						row.appendChild(button);
					}
					return row;
				]]>
				</body>
			</method>
			

			<method name="refresh">
				<parameter name="skipFields"/>
				<body>
				<![CDATA[
					if (this.blockRefresh) {
						this.blockRefresh = false;
						return;
					}

					
					if (!this.item) {

						Zotero.debug('No item to refresh', 2);
						return;
					}
					
					if (this.clickByItem) {
						var itemBox = document.getAnonymousNodes(this)[0];
						itemBox.setAttribute('onclick',
							'document.getBindingParent(this).clickHandler(this)');
					}
					
					// Item type menu
					if (this.showTypeMenu) {
						// Build item type menu if it hasn't been built yet
						if (this.itemTypeMenu.itemCount == 0) {
							this.buildItemTypeMenu();
						}
						else {
							this.updateItemTypeMenuSelection();
						}
						
						this.itemTypeMenu.parentNode.hidden = false;
					}
					else {
						this.itemTypeMenu.parentNode.hidden = true;
					}
					
					//
					// Clear and rebuild metadata fields
					//
					if (skipFields) {
						var nodes = document.evaluate('*[local-name()="rows" and contains(@class,"creator")]', this._dynamicFields, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
						for (var i=nodes.snapshotLength-1;i>-1;i--) {
							var node = nodes.snapshotItem(i);
							node.parentNode.removeChild(node);
						}
					} else {
						while (this._dynamicFields.childNodes.length > 1) {
							this._dynamicFields.removeChild(this._dynamicFields.lastChild);
						}
					}
					
					var fieldNames = [];
					
					// Manual field order
					if (this._fieldOrder.length) {
						for (let field of this._fieldOrder) {
							fieldNames.push(field);
						}
					}
					// Get field order from database
					else {
						if (!this.showTypeMenu) {
							fieldNames.push("itemType");
						}
						
						var fields = Zotero.ItemFields.getItemTypeFields(this.item.getField("itemTypeID"));
						
						for (var i=0; i<fields.length; i++) {
							fieldNames.push(Zotero.ItemFields.getName(fields[i]));
						}
						
						if (!(this.item instanceof Zotero.FeedItem)) {
							fieldNames.push("dateAdded", "dateModified");
						}
					}
					
					if (!skipFields) {
						var tabCount = this._tabIndexMinFields;
						for (var i=0; i<fieldNames.length; i++) {
							var fieldName = fieldNames[i];
							var virtualTabCount = i>0 ? tabCount : 1;
							var mainRow = this.addFieldRow(virtualTabCount,fieldName);
							tabCount += 1;
							var multiData = this.item.multi.data(fieldName);
							if (multiData.length) {
								// XXX Add a rows sibling
								var multiRows = document.createElement('rows');
								multiRows.classList.add('multi');
								var nextRow = mainRow.nextSibling;
								mainRow.parentNode.insertBefore(multiRows, nextRow);
								for (var j=0,jlen=multiData.length;j<jlen;j++) {
									var variantData = multiData[j];
									this.addFieldRow(tabCount, fieldName, variantData.value, multiRows, null, variantData.languageTag);
									tabCount += 1;
								}
							}
						}
					}

// OH DEAR (start)
					for (var i=0; i<fieldNames.length; i++) {
						var fieldName = fieldNames[i];
						var val = '';
						
						if (fieldName) {
							var fieldID = Zotero.ItemFields.getID(fieldName);
							if (fieldID && !Zotero.ItemFields.isValidForType(fieldID, this.item.itemTypeID)) {
								fieldName = null;
							}
						}
						
						if (fieldName) {
							if (this._hiddenFields.indexOf(fieldName) != -1) {
								continue;
							}
							
							// createValueElement() adds the itemTypeID as an attribute
							// and converts it to a localized string for display
							if (fieldName == 'itemType') {
								val = this.item.itemTypeID;
							}
							else {
								val = this.item.getField(fieldName);
							}
							
							if (!val && this.hideEmptyFields
									&& this._visibleFields.indexOf(fieldName) == -1
									&& (this.mode != 'fieldmerge' || typeof this._fieldAlternatives[fieldName] == 'undefined')) {
								continue;
							}
							
							var fieldIsClickable = this._fieldIsClickable(fieldName);
							
							// Start tabindex at 1001 after creators
							var tabindex = fieldIsClickable
								? (i>0 ? this._tabIndexMinFields + i : 1) : 0;
							this._tabIndexMaxFields = Math.max(this._tabIndexMaxFields, tabindex);
							
							if (fieldIsClickable
									&& !Zotero.Items.isPrimaryField(fieldName)
									&& (Zotero.ItemFields.isFieldOfBase(Zotero.ItemFields.getID(fieldName), 'date')
										// TEMP - filingDate
										|| fieldName == 'filingDate')
									// TEMP - NSF
									&& fieldName != 'dateSent') {
								this.addDateRow(fieldNames[i], this.item.getField(fieldName, true), tabindex);
								continue;
							}
						}
						
						let label = document.createElement("label");
						label.setAttribute('fieldname', fieldName);
						
						let valueElement = this.createValueElement(
							val, fieldName, tabindex
						);
						
						var prefix = '';
						// Add '(...)' before 'Abstract' for collapsed abstracts
						if (fieldName == 'abstractNote') {
							if (val && !Zotero.Prefs.get('lastAbstractExpand')) {
								prefix = '(\u2026) ';
							}
						}
						
						if (fieldName) {
							label.setAttribute("value", prefix +
								Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, fieldName));
						}
						
						// TEMP - NSF (homepage)
						if ((fieldName == 'url' || fieldName == 'homepage') && val) {
							label.classList.add("pointer");
							// TODO: make getFieldValue non-private and use below instead
							label.setAttribute("onclick", "ZoteroPane_Local.loadURI(this.nextSibling.firstChild ? this.nextSibling.firstChild.nodeValue : this.nextSibling.value, event)");
							label.setAttribute("tooltiptext", Zotero.getString('locate.online.tooltip'));
						}
						else if (fieldName == 'DOI' && val && typeof val == 'string') {
							// Pull out DOI, in case there's a prefix
							var doi = Zotero.Utilities.cleanDOI(val);
							if (doi) {
								doi = "https://doi.org/" + encodeURIComponent(doi);
								label.classList.add("pointer");
								label.setAttribute("onclick", "ZoteroPane_Local.loadURI('" + doi + "', event)");
								label.setAttribute("tooltiptext", Zotero.getString('locate.online.tooltip'));
								valueElement.setAttribute('contextmenu', 'zotero-doi-menu');
								
								var openURLMenuItem = document.getElementById('zotero-doi-menu-view-online');
								openURLMenuItem.setAttribute("oncommand", "ZoteroPane_Local.loadURI('" + doi + "', event)");
								
								var copyMenuItem = document.getElementById('zotero-doi-menu-copy');
								copyMenuItem.setAttribute("oncommand", "Zotero.Utilities.Internal.copyTextToClipboard('" + doi + "')");
							}
						}
						else if (fieldName == 'abstractNote') {
							if (val.length) {
								label.classList.add("pointer");
							}
							label.addEventListener('click', function () {
								if (this.nextSibling.inputField) {
									this.nextSibling.inputField.blur();
								}
							})
						}
					}
// OH DEAR (end)	
					//
					// Creators
					//
					
					// Creator type menu
					if (this.editable) {
						while (this._creatorTypeMenu.hasChildNodes()) {
							this._creatorTypeMenu.removeChild(this._creatorTypeMenu.firstChild);
						}
						
						var creatorTypes = Zotero.CreatorTypes.getTypesForItemType(this.item.itemTypeID);

						var localized = {};
						for (var i=0; i<creatorTypes.length; i++) {
							localized[creatorTypes[i]['name']]
								= Zotero.getString('creatorTypes.' + creatorTypes[i]['name']);
						}
						
						for (var i in localized) {
							var menuitem = document.createElement("menuitem");
							menuitem.setAttribute("label", localized[i]);
							menuitem.setAttribute("typeid", Zotero.CreatorTypes.getID(i));
							this._creatorTypeMenu.appendChild(menuitem);
						}
						
						var moveSep = document.createElement("menuseparator");
						var moveUp = document.createElement("menuitem");
						var moveDown = document.createElement("menuitem");
						moveSep.id = "zotero-creator-move-sep";
						moveUp.id = "zotero-creator-move-up";
						moveDown.id = "zotero-creator-move-down";
						moveUp.className = "zotero-creator-move";
						moveDown.className = "zotero-creator-move";
						moveUp.setAttribute("label", Zotero.getString('pane.item.creator.moveUp'));
						moveDown.setAttribute("label", Zotero.getString('pane.item.creator.moveDown'));
						this._creatorTypeMenu.appendChild(moveSep);
						this._creatorTypeMenu.appendChild(moveUp);
						this._creatorTypeMenu.appendChild(moveDown);
					}

					// Creator rows
					
					// Place, in order of preference, after title, after type,
					// or at beginning
					var titleFieldID = Zotero.ItemFields.getFieldIDFromTypeAndBase(this.item.itemTypeID, 'title');
					var field = this._dynamicFields.getElementsByAttribute('fieldname', Zotero.ItemFields.getName(titleFieldID)).item(0);
					if (!field) {
						var field = this._dynamicFields.getElementsByAttribute('fieldname', 'itemType').item(0);
					}
					if (field && field.parentNode.nextSibling) {
						if ('rows' === field.parentNode.nextSibling.tagName) {
							this._beforeRow = field.parentNode.nextSibling.nextSibling;
						}
						else {
							this._beforeRow = field.parentNode.nextSibling;
						}
					}
					else {
						this._beforeRow = this._dynamicFields.firstChild;
					}
					
					this._creatorCount = 0;
					var num = this.item.numCreators();
					if (num > 0) {
						// Limit number of creators display
						var max = Math.min(num, this._initialVisibleCreators);
						// If only 1 or 2 more, just display
						if (num < max + 3 || this._displayAllCreators) {
							max = num;
						}
						for (var i = 0; i < max; i++) {
							var creator = this.item.getCreator(i);
							var row = this.addCreatorRow(creator,
								creator.creatorTypeID,
								null,
								null,
								null,
								null,
								creator.multi.main);
							
							// Display "+" button on all but last row
							if (i == max - 2) {
								this.disableCreatorAddButtons();
							}
							
							var langs = Object.keys(creator.multi._key);
							langs.sort();
							if (langs.length) {
								var mainRow = row.firstChild;
								var rows = mainRow.nextSibling;
								if (!rows || rows.tagName !== 'rows' || !rows.classList.contains('multi')) {
									rows = document.createElement('rows');
									rows.classList.add('multi');
									mainRow.parentNode.appendChild(rows);
								}
								for (var j=0,jlen=langs.length;j<jlen;j++) {
									var multicreator = creator.multi._key[langs[j]];
									this.addCreatorRow(multicreator,
										creator.creatorTypeID,
										null,
										null,
										rows,
										null,
										langs[j]);
								}
							}

						}
						
						// Additional creators not displayed
						if (num > max) {
							this.addMoreCreatorsRow(num - max);
							
							this.disableCreatorAddButtons();
						}
						else {
							// If we didn't start with creators truncated,
							// don't truncate for as long as we're viewing
							// this item, so that added creators aren't
							// immediately hidden
							this._displayAllCreators = true;
							
							if (this._addCreatorRow) {
								this.addCreatorRow(false, this.item.getCreator(max-1).creatorTypeID, true);
								this._addCreatorRow = false;
								this.disableCreatorAddButtons();
							}
						}
					}
					else if (this.editable && Zotero.CreatorTypes.itemTypeHasCreators(this.item.itemTypeID)) {
						// Add default row
						this.addCreatorRow(false, false, true, true);
						this.disableCreatorAddButtons();
					}
					
					this.multiTabUpdate();

					// Move to next or previous field if (shift-)tab was pressed
					if (this._lastTabIndex && this._lastTabIndex != -1) {
						this._focusNextField(this._lastTabIndex);
					}
					
					this._refreshed = true;
				]]>
				</body>
			</method>
			
			
		<method name="buildItemTypeMenu">
				<body>
				<![CDATA[
					if (!this.item) {
						return;
					}
					
					this.itemTypeMenu.removeAllItems();
					
					var t = Zotero.ItemTypes.getTypes();
							
					// Sort by localized name
					var itemTypes = [];
					for (var i=0; i<t.length; i++) {
						itemTypes.push({
							id: t[i].id,
							name: t[i].name,
							localized: Zotero.ItemTypes.getLocalizedString(t[i].id)
						});
					}
					var collation = Zotero.getLocaleCollation();
					itemTypes.sort(function(a, b) {
						return collation.compareString(1, a.localized, b.localized);
					});
					
					for (var i=0; i<itemTypes.length; i++) {
						var name = itemTypes[i].name;
						if (name != 'attachment' && name != 'note') {
							this.itemTypeMenu.appendItem(itemTypes[i].localized, itemTypes[i].id);
						}
					}
					
					this.updateItemTypeMenuSelection();
				]]>
				</body>
			</method>
			
			
			<method name="updateItemTypeMenuSelection">
				<body>
				<![CDATA[
					var listitems = this.itemTypeMenu.firstChild.childNodes;
					for (var i=0, len=listitems.length; i < len; i++) {
						if (listitems[i].getAttribute('value') == this.item.itemTypeID) {
							this.itemTypeMenu.selectedIndex = i;
						}
					}
				]]>
				</body>
			</method>
			
			
			<method name="addDynamicRow">
				<parameter name="label"/>
				<parameter name="value"/>
				<parameter name="addBeforeElement"/>
				<parameter name="isCreatorElement"/>
				<parameter name="parentElement"/>
				<parameter name="nextElement"/>
				<body>
				<![CDATA[
						 
					var isMulti = false;
					if (parentElement && parentElement.classList.contains('multi')) {
						isMulti = true;
					}
					// Add click event to row
					if (this._rowIsClickable(value.getAttribute('fieldname'))) {
						row.classList.add('zotero-clicky');
						row.addEventListener('click', function (event) {
							document.getBindingParent(this).clickHandler(this);
						}, false);
					}
					
					if (!isMulti && value.getAttribute('fieldname') == 'gazetteFlag') {
						var value = document.createElement("hbox");
						var gazetteFlag = document.createElement("checkbox");
						// gazetteFlag.setAttribute("label","gazette");
						gazetteFlag.setAttribute("id","gazette-flag");
						gazetteFlag.setAttribute("oncommand","document.getBindingParent(this).gazetteFlagCommand(this);");
						if (this.item.getField("gazetteFlag")) {
							gazetteFlag.setAttribute("checked",true);
						}
						value.appendChild(gazetteFlag);
						var row = document.createElement("row");
						row.appendChild(label);
						row.appendChild(value);

					} else if (!isMulti && value.getAttribute('fieldname') == 'jurisdiction') {
						var innerValue = value;
						innerValue.setAttribute("tooltiptext", value.getAttribute("label"));
						value = document.createElement("hbox");
						value.appendChild(innerValue);
						var jurisdictionDefault = document.createElement("checkbox");
						jurisdictionDefault.setAttribute("label","default");
						jurisdictionDefault.setAttribute("id","jurisdiction-default");
						jurisdictionDefault.setAttribute("oncommand","document.getBindingParent(this).jurisdictionDefaultCommand(this);");
						if (this.item.getField("jurisdiction", true) === Zotero.Prefs.get("import.jurisdictionDefault")) {
							jurisdictionDefault.setAttribute("checked",true);
						}
						value.appendChild(jurisdictionDefault);
						var row = document.createElement("row");
						row.appendChild(label);
						row.appendChild(value);
					} else if (!isMulti && value.getAttribute('fieldname') == 'court') {
						//value.setAttribute("tooltiptext", value.getAttribute("label"));
						var row = document.createElement("row");
						row.appendChild(label);
						var boxedvalue = document.createElement("hbox");
						boxedvalue.appendChild(value);
						row.appendChild(boxedvalue);
					} else if (isCreatorElement && !isMulti) {
						var row = document.createElement('rows');
						row.classList.add('creator');
						var subrow = document.createElement('row');
						row.appendChild(subrow);
						subrow.appendChild(label);
						subrow.appendChild(value);
					} else {
						var row = document.createElement("row");
						row.appendChild(label);
						row.appendChild(value);
					}


					if (!parentElement) {
						parentElement = this._dynamicFields;
					}
					var elementToPlaceBefore = null;
					if (nextElement) {
						elementToPlaceBefore = nextElement;
					} else if (addBeforeElement) {
						elementToPlaceBefore = this._beforeRow;
					}
					if (elementToPlaceBefore) {
						parentElement.insertBefore(row, elementToPlaceBefore);
					}
					else {
						parentElement.appendChild(row);
					}
					
					return row;
				]]>
				</body>
			</method>
			
			<method name="jurisdictionDefaultCommand">
			  <parameter name="node"/>
			  <body>
				<![CDATA[
					var checked = node.getAttribute("checked");
					if (checked) {
						var jurisdictionNode = document.getElementById("jurisdiction-menu");
						var jurisdiction = jurisdictionNode.getAttribute("value");
						Zotero.Prefs.set("import.jurisdictionDefault",jurisdiction);
					} else {
						Zotero.Prefs.set("import.jurisdictionDefault","");
					}
				]]>
			  </body>
			</method>

			<method name="gazetteFlagCommand">
			  <parameter name="node"/>
			  <body>
				<![CDATA[
					var checked = node.getAttribute("checked");
					if (checked) {
						this.item.setField("gazetteFlag", "1");
					} else {
						this.item.setField("gazetteFlag", "");
					}
					this.item.saveTx();
				]]>
			  </body>
			</method>
			
			<method name="addCreatorRow">
				<parameter name="creatorData"/>
				<parameter name="creatorTypeIDOrName"/>
				<parameter name="unsaved"/>
				<parameter name="defaultRow"/>
				<parameter name="parentNode"/>
				<parameter name="nextNode"/>
				<parameter name="langTag"/>
				<body>
				<![CDATA[
					// getCreatorFields(), switchCreatorMode() and handleCreatorAutoCompleteSelect()
					// may need need to be adjusted if this DOM structure changes
					
					var creatorPos = this._creatorCount;
					if (parentNode) {
						var parentLabel = parentNode.previousSibling.firstChild;
						creatorPos = parentLabel.getAttribute("fieldname").split("-")[1];
					}

					var fieldMode = Zotero.Prefs.get('lastCreatorFieldMode');
					var firstName = '';
					var lastName = '';
					if (creatorData) {
						fieldMode = creatorData.fieldMode;
						firstName = creatorData.firstName;
						lastName = creatorData.lastName;
					}
					
					// Sub in placeholder text for empty fields
					if (fieldMode == 1) {
						if (lastName === "") {
							lastName = this._defaultFullName;
						}
					}
					else {
						if (firstName === "") {
							firstName = this._defaultFirstName;
						}
						if (lastName === "") {
							lastName = this._defaultLastName;
						}
					}
					
					// Use the first entry in the drop-down for the default type if none specified
					var typeID = creatorTypeIDOrName
						? Zotero.CreatorTypes.getID(creatorTypeIDOrName)
						: this._creatorTypeMenu.childNodes[0].getAttribute('typeid');
					
					var typeBox = document.createElement("hbox");
					typeBox.setAttribute("typeid", typeID);
					if (!parentNode) {
						typeBox.addEventListener('click',function(event){
							document.getBindingParent(this).openCreatorTypeMenu(event);
						});
					}
					
					typeBox.setAttribute("fieldname", 'creator-' + creatorPos + '-typeID');
					if (langTag) {
						typeBox.setAttribute("zlang", langTag);
						typeBox.setAttribute("tooltiptext", Zotero.CachedLanguages.getNickname(langTag));
					}
					if (this.editable) {
						typeBox.setAttribute("contextmenu", "mlz-language-menu");
						if (!parentNode) {
							typeBox.className = 'creator-type-label zotero-clicky';
							var img = document.createElement('image');
							typeBox.appendChild(img);
						} else {
							typeBox.classList.add('creator-type-label');
							typeBox.classList.add('zotero-alien-clicky');
						}
					}
					else {
						typeBox.className = 'creator-type-label';
					}
					
					var label = document.createElement("label");
					if (!parentNode) {
						label.setAttribute('value',
							Zotero.getString('creatorTypes.'+Zotero.CreatorTypes.getName(typeID)))
					} else {
						label.setAttribute('value', Zotero.CachedLanguages.getNickname(langTag));
					}
					typeBox.appendChild(label);
					var hbox = document.createElement("hbox");
					hbox.className = 'creator-type-value';
					
					// Name
					var firstlast = document.createElement("hbox");
					firstlast.className = 'creator-name-box';
					firstlast.setAttribute("flex","1");
					var tabindex = this._tabIndexMinCreators + (this._creatorCount * 2);
					var fieldName = 'creator-' + creatorPos + '-lastName';
					var lastNameLabel = firstlast.appendChild(
						this.createValueElement(
							lastName,
							fieldName,
							tabindex
						)
					);
					
					// Comma
					var comma = document.createElement('label');
					comma.setAttribute('value', ',');
					comma.className = 'comma';
					firstlast.appendChild(comma);
					
					var fieldName = 'creator-' + creatorPos + '-firstName';
					firstlast.appendChild(
						this.createValueElement(
							firstName,
							fieldName,
							tabindex + 1
						)
					);
					if (fieldMode) {
						firstlast.lastChild.setAttribute('hidden', true);
					}
					
					if (this.editable && fieldMode == 0) {
						firstlast.setAttribute('contextmenu', 'zotero-creator-transform-menu');
					}
					
					this._tabIndexMaxCreators = Math.max(this._tabIndexMaxCreators, tabindex);
					
					hbox.appendChild(firstlast);
					
					// Single/double field toggle
					var toggleButton = document.createElement('label');
					toggleButton.setAttribute('fieldname',
						'creator-' + creatorPos + '-' + fieldMode);
					toggleButton.className = 'zotero-field-toggle zotero-clicky';
					hbox.appendChild(toggleButton);
					
					// Minus (-) button
					var removeButton = document.createElement('label');
					removeButton.setAttribute("value","-");
					removeButton.setAttribute("class","zotero-clicky zotero-clicky-minus");
					// If default first row, don't let user remove it
					if (defaultRow) {
						this.disableButton(removeButton);
					}
					else {
						removeButton.setAttribute("onclick",
							"document.getBindingParent(this).removeCreator("
							+ creatorPos
							+ ", this.parentNode.parentNode)");
					}
					hbox.appendChild(removeButton);
					
					// Plus (+) button
					var addButton = document.createElement('label');
					addButton.setAttribute("value","+");
					addButton.setAttribute("class", "zotero-clicky zotero-clicky-plus");
					// If row isn't saved, don't let user add more
					if (unsaved) {
						this.disableButton(addButton);
					}
					else {
						this._enablePlusButton(addButton, typeID, fieldMode);
					}
					hbox.appendChild(addButton);
					
					if (parentNode) {
						toggleButton.setAttribute('hidden', true);
						//removeButton.setAttribute('hidden', true);
						addButton.setAttribute('hidden', true);
					} else {
						this._creatorCount++;
					}
					
					if (!this.editable) {
						toggleButton.hidden = true;
						removeButton.hidden = true;
						addButton.hidden = true;
					}

					var placementFlag = true;
					if (parentNode) {
						placementFlag = false;
					}
					var p = parentNode ? parentNode.ownerDocument : parentNode;
					var n = nextNode ? nextNode.ownerDocument : nextNode;
					var row = this.addDynamicRow(typeBox, hbox, placementFlag, true, parentNode, nextNode);

					if (unsaved) {
						this.multiTabUpdate();
					}

					// Set single/double field toggle mode
					// isMulti "detection" for this function is a real mess.
					var isMulti = false;
					if (parentNode || creatorData.multi) {
					    isMulti = true;
					} 
					if (fieldMode) {
						this.switchCreatorMode(hbox.parentNode, 1, true, false, isMulti);
					}
					else {
						this.switchCreatorMode(hbox.parentNode, 0, true, false, isMulti);
					}

					// Focus new rows
					if (unsaved && !defaultRow){
						lastNameLabel.click();
					}

					return row;
				]]>
				</body>
			</method>
			

			<method name="openCreatorTypeMenu">
				<parameter name="event"/>
				<body>
				<![CDATA[
							if (event.button !== 0) return true;
							var popupNode = event.target;
							var row = Zotero.getAncestorByTagName(popupNode, "row");
							var fieldParent = row.firstChild.nextSibling.firstChild;
							var inputField = null;
							if (fieldParent.firstChild.inputField) {
								var inputField = fieldParent.firstChild.inputField;
							} else if (fieldParent.lastChild.inputField) {
								var inputField = fieldParent.lastChild.inputField;
							}
							if (inputField) {
								setTimeout(function() {
									inputField.blur();
								}, 50);
							} else {
								var menuNode = document.getBindingParent(popupNode)._creatorTypeMenu;
								document.popupNode = popupNode;
								menuNode.openPopup(popupNode, "after_start", 0, 0, false, false);
							}
				]]>
				</body>
			</method>
			

			<method name="addMoreCreatorsRow">
				<parameter name="num"/>
				<body>
				<![CDATA[
					var box = document.createElement('box');
					
					var label = document.createElement('label');
					label.id = 'more-creators-label';
					label.setAttribute('value', Zotero.getString('general.numMore', num));
					label.setAttribute('onclick',
						"var binding = document.getBindingParent(this); "
						+ "binding._displayAllCreators = true; "
						+ "binding.refresh()"
					);
					
					this.addDynamicRow(box, label, true, true);
				]]>
				</body>
			</method>
			
			<method name="addDateRow">
				<parameter name="field"/>
				<parameter name="value"/>
				<parameter name="tabindex"/>
				<body>
				<![CDATA[
					var label = document.createElement("label");
					label.setAttribute("value", Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, field));
					label.setAttribute("fieldname", field);
					label.setAttribute("onclick", "this.nextSibling.firstChild.blur()");
					
					var elem = this.createValueElement(
						Zotero.Date.multipartToStr(value),
						field,
						tabindex
					);
					elem.setAttribute('flex', 1);
					
					// y-m-d status indicator
					var ymd = document.createElement('label');
					ymd.id = 'zotero-date-field-status';
					ymd.setAttribute(
						'value',
						Zotero.Date.strToDate(Zotero.Date.multipartToStr(value))
							.order.split('').join(' ')
					);
					
					var hbox = document.createElement('hbox');
					hbox.setAttribute('flex', 1);
					hbox.className = "date-box";
					hbox.appendChild(elem);
					hbox.appendChild(ymd);
					
					this.addDynamicRow(label, hbox);
				]]>
				</body>
			</method>
			
			
			<method name="switchCreatorModeOnAll">
				<parameter name="row"/>
				<parameter name="fieldMode"/>
				<parameter name="initial"/>
				<parameter name="updatePref"/>
				<body>
				<![CDATA[
					var rows = row.nextSibling;
					this.saveOnEdit = false;
					if (rows && rows.tagName === 'rows' && rows.classList.contains('multi')) {
						for (var i=0,ilen=rows.childNodes.length;i<ilen;i++) {
							this.switchCreatorMode(rows.childNodes[i], fieldMode, initial, false, true);
						}
					}
					this.saveOnEdit = true;
					this.switchCreatorMode(row, fieldMode, initial, false, false);
				]]>
				</body>
			</method>
			
			

			<method name="switchCreatorMode">
				<parameter name="row"/>
				<parameter name="fieldMode"/>
				<parameter name="initial"/>
				<parameter name="updatePref"/>
				<parameter name="isMulti"/>
				<body>
				<![CDATA[
					// Change if button position changes
					// row->hbox->label->label->toolbarbutton
					var button = row.lastChild.lastChild.previousSibling.previousSibling;
					var hbox = button.previousSibling;
					var lastName = hbox.firstChild;
					var comma = hbox.firstChild.nextSibling;
					var firstName = hbox.firstChild.nextSibling.nextSibling;
					var langTag = row.firstChild.getAttribute("zlang");
					
					// Switch to single-field mode
					if (fieldMode == 1) {
						button.style.background = `url("chrome://zotero/skin/textfield-dual${Zotero.hiDPISuffix}.png") center/21px auto no-repeat`;
						button.setAttribute('tooltiptext', Zotero.getString('pane.item.switchFieldMode.two'));
						lastName.setAttribute('fieldMode', '1');
						button.setAttribute('onclick', "document.getBindingParent(this).switchCreatorModeOnAll(Zotero.getAncestorByTagName(this, 'row'), 0, false, true)");
						lastName.setAttribute('flex', '1');
						delete lastName.style.width;
						delete lastName.style.maxWidth;
						
						// Remove firstname field from tabindex
						var tab = parseInt(firstName.getAttribute('ztabindex'));
						firstName.setAttribute('ztabindex', -1);
						if (this._tabIndexMaxCreators == tab) {
							this._tabIndexMaxCreators--;
						}
						
						// Hide first name field and prepend to last name field
						firstName.setAttribute('hidden', true);
						comma.setAttribute('hidden', true);
						
						if (!initial) {
							var first = this._getFieldValue(firstName);
							if (first && first != this._defaultFirstName) {
								var last = this._getFieldValue(lastName);
								this._setFieldValue(lastName, first + ' ' + last);
							}
						}
						
						if (this._getFieldValue(lastName) == this._defaultLastName) {
							this._setFieldValue(lastName, this._defaultFullName);
						}
					}
					// Switch to two-field mode
					else {
						button.style.background = `url("chrome://zotero/skin/textfield-single${Zotero.hiDPISuffix}.png") center/21px auto no-repeat`;
						button.setAttribute('tooltiptext', Zotero.getString('pane.item.switchFieldMode.one'));
						lastName.setAttribute('fieldMode', '0');
						button.setAttribute('onclick', "document.getBindingParent(this).switchCreatorModeOnAll(Zotero.getAncestorByTagName(this, 'row'), 1, false, true)");
						lastName.setAttribute('flex', '0');
						
						// appropriately truncate lastName
						
						// get item box width
						var computedStyle = window.getComputedStyle(this, null);
						var boxWidth = computedStyle.getPropertyValue('width');
						// get field label width
						var computedStyle = window.getComputedStyle(row.firstChild, null);
						var leftHboxWidth = computedStyle.getPropertyValue('width');
						// get last name width
						computedStyle = window.getComputedStyle(lastName, null);
						var lastNameWidth = computedStyle.getPropertyValue('width');
						if(boxWidth.substr(-2) === 'px'
								&& leftHboxWidth.substr(-2) === 'px'
								&& lastNameWidth.substr(-2) === "px") {
							// compute a maximum width
							boxWidth = parseInt(boxWidth);
							leftHboxWidth = parseInt(leftHboxWidth);
							lastNameWidth = parseInt(lastNameWidth);
							var maxWidth = boxWidth-leftHboxWidth-140;
							if(lastNameWidth > maxWidth) {
								lastName.style.width = maxWidth+"px";
								lastName.style.maxWidth = maxWidth+"px";
							} else {
								delete lastName.style.width;
								delete lastName.style.maxWidth;
							}
						}
						
						// Add firstname field to tabindex
						var tab = parseInt(lastName.getAttribute('ztabindex'));
						firstName.setAttribute('ztabindex', tab + 1);
						if (this._tabIndexMaxCreators == tab)
						{
							this._tabIndexMaxCreators++;
						}
						
						if (!initial) {
							// Move all but last word to first name field and show it
							var last = this._getFieldValue(lastName);
							if (last && last != this._defaultFullName) {
								var lastNameRE = /(.*?)[ ]*([^ ]+[ ]*)$/;
								var parts = lastNameRE.exec(last);
								if (parts[2] && parts[2] != last)
								{
									this._setFieldValue(lastName, parts[2]);
									this._setFieldValue(firstName, parts[1]);
								}
							}
						}
						
						if (!this._getFieldValue(firstName)) {
							this._setFieldValue(firstName, this._defaultFirstName);
						}
						
						if (this._getFieldValue(lastName) == this._defaultFullName) {
							this._setFieldValue(lastName, this._defaultLastName);
						}
						
						firstName.setAttribute('hidden', false);
						comma.setAttribute('hidden', false);
					}
					
					// Save the last-used field mode
					if (updatePref) {
						Zotero.debug("Switching lastCreatorFieldMode to " + fieldMode);
						Zotero.Prefs.set('lastCreatorFieldMode', fieldMode);
					}
					
					if (!initial)
					{
						var index = button.getAttribute('fieldname').split('-')[1];
						var fields = this.getCreatorFields(row);
						fields.fieldMode = fieldMode;
						this.modifyCreator(index, fields, langTag, isMulti);
						if (this.saveOnEdit) {
							// See note in transformText()
							this.blurOpenField().then(() => this.item.saveTx());
						}
					}
				]]>
				</body>
			</method>
			
			
			<method name="scrollToTop">
				<body>
				<![CDATA[
					// DEBUG: Valid nsIScrollBoxObject but methods return errors
					try {
						var sbo = document.getAnonymousNodes(this)[0].boxObject;
						sbo.QueryInterface(Components.interfaces.nsIScrollBoxObject);
						sbo.scrollTo(0,0);
					}
					catch (e) {
						Zotero.logError(e);
					}
				]]>
				</body>
			</method>
			
			
			<method name="ensureElementIsVisible">
				<parameter name="elem"/>
				<body>
				<![CDATA[
					var sbo = document.getAnonymousNodes(this)[0].boxObject;
					sbo.ensureElementIsVisible(elem);
				]]>
				</body>
			</method>
			
			
			<method name="changeTypeTo">
				<parameter name="itemTypeID"/>
				<parameter name="menu"/>
				<body>
				<![CDATA[
					if (itemTypeID == this.item.itemTypeID) {
						return true;
					}
					
					var fieldsToDelete = this.item.getFieldsNotInType(itemTypeID, true);
					
					// Special cases handled below
					var bookTypeID = Zotero.ItemTypes.getID('book');
					var bookSectionTypeID = Zotero.ItemTypes.getID('bookSection');
					
					// Add warning for shortTitle when moving from book to bookSection
					// when title will be transferred
					if (this.item.itemTypeID == bookTypeID && itemTypeID == bookSectionTypeID) {
						var titleFieldID = Zotero.ItemFields.getID('title');
						var shortTitleFieldID = Zotero.ItemFields.getID('shortTitle');
						if (this.item.getField(titleFieldID) && this.item.getField(shortTitleFieldID)) {
							if (!fieldsToDelete) {
								fieldsToDelete = [];
							}
							fieldsToDelete.push(shortTitleFieldID);
						}
					}
					
					// Generate list of localized field names for display in pop-up
					if (fieldsToDelete) {
						// Ignore warning for bookTitle when going from bookSection to book
						// if there's not also a title, since the book title is transferred
						// to title automatically in Zotero.Item.setType()
						if (this.item.itemTypeID == bookSectionTypeID && itemTypeID == bookTypeID) {
							var titleFieldID = Zotero.ItemFields.getID('title');
							var bookTitleFieldID = Zotero.ItemFields.getID('bookTitle');
							var shortTitleFieldID = Zotero.ItemFields.getID('shortTitle');
							if (this.item.getField(bookTitleFieldID) && !this.item.getField(titleFieldID)) {
								var index = fieldsToDelete.indexOf(bookTitleFieldID);
								fieldsToDelete.splice(index, 1);
								// But warn for short title, which will be removed
								if (this.item.getField(shortTitleFieldID)) {
									fieldsToDelete.push(shortTitleFieldID);
								}
							}
						}
						
						var fieldNames = "";
						for (var i=0; i<fieldsToDelete.length; i++) {
							fieldNames += "\n - " +
								Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, fieldsToDelete[i]);
						}
						
						var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
							.getService(Components.interfaces.nsIPromptService);
					}
					
					if (!fieldsToDelete || fieldsToDelete.length == 0 ||
							promptService.confirm(null,
								Zotero.getString('pane.item.changeType.title'),
								Zotero.getString('pane.item.changeType.text') + "\n" + fieldNames)) {
						this.item.setType(itemTypeID);
						
						// Force jurisdiction value if required
						this.forceJurisdiction(itemTypeID);
						
						if (this.saveOnEdit) {
							// See note in transformText()
							this.blurOpenField().then(() => this.item.saveTx());
						}
						else {
							this.refresh();
						}
						
						if (this.eventHandlers['itemtypechange'] && this.eventHandlers['itemtypechange'].length) {
							var self = this;
							this.eventHandlers['itemtypechange'].forEach(function (f) f.bind(self)());
						}
						
						return true;
					}
					
					// Revert the menu (which changes before the pop-up)
					if (menu) {
						menu.value = this.item.itemTypeID;
					}
					
					return false;
				]]>
				</body>
			</method>
			
			
			<method name="forceJurisdiction">
				<parameter name="itemTypeID"/>
				<body>
				<![CDATA[
						var jurisdictionID = Zotero.ItemFields.getID('jurisdiction');
						var fields = Zotero.ItemFields.getItemTypeFields(itemTypeID);
						if (fields.indexOf(jurisdictionID) > -1) {
							var itemType = Zotero.ItemTypes.getName(itemTypeID);
							if (["report","newspaperArticle","journalArticle", "standard"].indexOf(itemType) === -1) {
								if (!this.item.getField(jurisdictionID)) {
									var jurisdictionDefault = Zotero.Prefs.get("import.jurisdictionDefault");
									var jurisdictionFallback = Zotero.Prefs.get("import.jurisdictionFallback");
									if (jurisdictionDefault) {
										this.setJurisdictionKey(jurisdictionDefault);
									} else if (jurisdictionFallback) {
										this.setJurisdictionKey(jurisdictionFallback);
									} else {
										this.setJurisdictionKey("us");
									}
								}
							}
						}
				]]>
				</body>
			</method>

			
			<method name="toggleAbstractExpand">
				<parameter name="label"/>
				<parameter name="valueElement"/>
				<body>
				<![CDATA[
					var cur = Zotero.Prefs.get('lastAbstractExpand');
					Zotero.Prefs.set('lastAbstractExpand', !cur);
					
					var valueText = this.item.getField('abstractNote');
					var tabindex = valueElement.getAttribute('ztabindex');
					var newValueElement = this.createValueElement(
						valueText,
						'abstractNote',
						tabindex
					);
					valueElement.parentNode.replaceChild(newValueElement, valueElement);
					
					var text = Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, 'abstractNote');
					// Add '(...)' before "Abstract" for collapsed abstracts
					if (valueText && cur) {
						text = '(\u2026) ' + text;
					}
					label.setAttribute('value', text);
				]]>
				</body>
			</method>
			
			
			<method name="disableButton">
				<parameter name="button"/>
				<body>
				<![CDATA[
					button.setAttribute('disabled', true);
					button.setAttribute('onclick', false); 
				]]>
				</body>
			</method>
			
			
			<method name="_enablePlusButton">
				<parameter name="button"/>
				<parameter name="creatorTypeID"/>
				<parameter name="fieldMode"/>
				<body>
				<![CDATA[
					button.setAttribute('disabled', false);
					button.onclick = function () {
						var parent = document.getBindingParent(this);
						parent.disableButton(this);
						parent.addCreatorRow(null, creatorTypeID, true);
					};
				]]>
				</body>
			</method>
			
			
			<method name="disableCreatorAddButtons">
				<body>
				<![CDATA[
					// Disable the "+" button on all creator rows
					var elems = this._dynamicFields.getElementsByAttribute('value', '+');
					for (var i = 0, len = elems.length; i < len; i++) {
						this.disableButton(elems[i]);
					}
				]]>
				</body>
			</method>
			
			
			<method name="showJurisdictionEditor">
				<parameter name="node"/>
				<body>
				<![CDATA[
					var tabindex = node.getAttribute("ztabindex");
					var value = node.getAttribute('label');
					var textbox = document.createElement('textbox');
					textbox.setAttribute("ztabindex", tabindex);
					textbox.setAttribute('value',value);
					textbox.setAttribute("oldComment",node.getAttribute("value"));
					textbox.setAttribute("oldValue",node.getAttribute("label"));
					textbox.setAttribute("flex","1");
					textbox.setAttribute('emptytext','Enter a jurisdiction');

					textbox.setAttribute('type','autocomplete');
					textbox.setAttribute('autocompletesearch','jurism');
					let params = {
						fieldName: "jurisdictions"
					}
					textbox.setAttribute('ontextentered',
						'document.getBindingParent(this).handleJurisdictionAutoCompleteSelect(this)');
					textbox.setAttribute(
						'autocompletesearchparam', JSON.stringify(params)
					);
					textbox.setAttribute('completeselectedindex', true);

					node.parentNode.replaceChild(textbox, node)
					
					textbox.setAttribute('onkeypress', "return document.getBindingParent(this).handleKeyPress(event)");

					textbox.addEventListener('blur', function (event) {
					  document.getBindingParent(this).hideJurisdictionEditor(this);
					}, false);
					textbox.select();
					this._tabDirection = false;
					this._lastTabIndex = tabindex;
				]]>
				</body>
			</method>


			<method name="showCourtEditor">
				<parameter name="node"/>
				<body>
				<![CDATA[
					var tabindex = node.getAttribute("ztabindex");
					var jurisdictionID = document.getElementById("jurisdiction-menu").getAttribute("value");
					var jurisdictionName = Zotero.CachedJurisdictionData.jurisdictionNameFromId(jurisdictionID, true);
					var countryID = jurisdictionID.split(":")[0];
					var value = node.getAttribute('label');
					var textbox = document.createElement('textbox');
					textbox.setAttribute("ztabindex", tabindex);
					textbox.setAttribute('value',value);
					textbox.setAttribute("oldComment",node.getAttribute("value"));
					textbox.setAttribute("oldValue",node.getAttribute("label"));
					textbox.setAttribute("flex","1");
					textbox.setAttribute('emptytext','Select a court or enter its name');

					textbox.setAttribute('type','autocomplete');
					textbox.setAttribute('autocompletesearch','jurism');
					let params = {
						fieldName: 'courts',
						jurisdictionName: jurisdictionName,
						countryID: countryID
					}
					textbox.setAttribute('ontextentered',
						'document.getBindingParent(this).handleCourtAutoCompleteSelect(this)');
					textbox.setAttribute(
						'autocompletesearchparam', JSON.stringify(params)
					);
					//textbox.setAttribute('completeselectedindex', true);
					textbox.setAttribute('enablehistory', true);
					textbox.setAttribute('highlightnonmatches', true);

					node.parentNode.replaceChild(textbox, node)

					textbox.setAttribute('onkeypress', "return document.getBindingParent(this).handleKeyPress(event)");

					textbox.addEventListener('blur', function (event) {
						document.getBindingParent(this).hideCourtEditor(this);
					}, false);
					textbox.select();
					this._tabDirection = false;
					this._lastTabIndex = tabindex;
				]]>
				</body>
			</method>


			<method name="handleJurisdictionKeypress">
				<parameter name="event"/>
				<body>
				<![CDATA[
				   //alert(textbox.mController);
				   var target = event.target;
				   var focused = document.commandDispatcher.focusedElement;
				   switch (event.keyCode) {
					 case event.DOM_VK_ESCAPE:
					 case event.DOM_VK_RETURN:
					   event.preventDefault();
					   event.target.blur();
					   break;
					 case event.DOM_VK_TAB:
					   this._tabDirection = event.shiftKey ? -1 : 1;
					   this._focusNextField(this._dynamicFields, this._lastTabIndex, this._tabDirection == -1);
					   event.preventDefault();
					   return true;
				   }
				   return false;
				]]>
				</body>
			</method>

			<method name="hideJurisdictionEditor">
				<parameter name="node"/>
				<parameter name="result"/>
				<body>
				<![CDATA[
				return (async function () {
					if (!result) {
						result = {val: node.getAttribute("oldValue"), comment: node.getAttribute("oldComment")};
					}
					if (!result.val) {
				  		var itemType = Zotero.ItemTypes.getName(this.item.itemTypeID);
				  		if (["report","newspaperArticle","journalArticle", "standard"].indexOf(itemType) == -1) {
				  			result = {val:node.getAttribute("oldValue"),comment:node.getAttribute("oldComment")};
				  		}
					}
					var tabindex = node.getAttribute("ztabindex");

					var valueElement = document.createElement("menulist");
					valueElement.setAttribute("id","jurisdiction-menu");
					valueElement.setAttribute("ztabindex", tabindex);
					valueElement.setAttribute("flex","1");
					valueElement.classList.add("zotero-clicky");
					valueElement.setAttribute("onclick","document.getBindingParent(this).showJurisdictionEditor(this);");
					valueElement.setAttribute("value",result.comment);
					valueElement.setAttribute("label",result.val);
					valueElement.setAttribute("tooltiptext",result.val);
					node.parentNode.replaceChild(valueElement,node);
					await this.setJurisdictionKey(result.comment);
					var xpath = '*[local-name()="row"]/'
						+ '*[local-name()="label" and @fieldname="court"]/'
						+ 'following-sibling::*[local-name()="hbox"]/'
						+ '*[local-name()="menulist"]';
					var courtNodes = document.evaluate(xpath, this._dynamicFields, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
					if (courtNodes.snapshotLength) {
						var courtNode = courtNodes.snapshotItem(0);
						var courtIdOrName = courtNode.getAttribute('value');
						var oldCourtName = courtNode.getAttribute('label');
						var oldJurisdictionID = node.getAttribute('oldComment');
						var newJurisdictionID = result.comment;
						var newCourtID = Zotero.CachedJurisdictionData.remapCourtName(oldJurisdictionID, newJurisdictionID, courtIdOrName);
						courtNode.setAttribute('value', newCourtID);
						var newCourtName = Zotero.CachedJurisdictionData.courtNameFromId(newJurisdictionID, newCourtID, true);
						// How did we do
						if (newCourtName) {
							courtNode.setAttribute('value', newCourtName);
							courtNode.classList.remove('yellow');
						} else {
							this.item.setField('court', oldCourtName);
							courtNode.setAttribute('value', oldCourtName);
							courtNode.classList.add('yellow');
						}
					}

					if (this._tabDirection) {
						var focusBox = this._dynamicFields;
						this._focusNextField(focusBox, this._lastTabIndex, this._tabDirection == -1);
					}
					if (this.saveOnEdit) {
						this.blockRefresh = true;
						await this.item.saveTx();
					}
				}.bind(this))();
				]]>
				</body>
			</method>


			<method name="hideCourtEditor">
				<parameter name="node"/>
				<parameter name="result"/>
				<parameter name="nonMatchHighlight"/>
				<body>
				<![CDATA[
				return (async function () {
					var valueElement = document.createElement("menulist");
					if (!result) {
						// Used when saving hand-typed content of the field (triggred on blur)
						// XXX Actually I think this never happens now
						var newValue = node.value;
						var jurisdictionID = this.item.getField('jurisdiction', true);
						var newComment = Zotero.CachedJurisdictionData.courtIdFromName(jurisdictionID, newValue, true);
						result = {val:newValue,comment:newComment};
						if ("undefined" == typeof result.comment) {
						    result.comment = result.val;
							valueElement.classList.add('yellow');
						}
					} else {
						// Used to adjust values when SAYT result from a subjurisdiction is selected.
						var m = result.val.match(/^([^:]+):\s+(.*)$/);
						if (m) {
							// Get the subjurisdiction element to add to the current jurisdiction
							var jurisdictionStub = m[1];
							result.val = m[2];
							var xpath = '*[local-name()="row"]/'
								+ '*[local-name()="label" and @fieldname="jurisdiction"]/'
								+ 'following-sibling::*[local-name()="hbox"]/'
								+ '*[local-name()="menulist"]';
							var jurisdictionNodes = document.evaluate(xpath, this._dynamicFields, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
							if (jurisdictionNodes.snapshotLength) {
								// Get the currently displayed name value
								var jurisdictionNode = jurisdictionNodes.snapshotItem(0);
								var jurisdictionName = jurisdictionNode.getAttribute('label');
								// Get the canonical long-form country name (awkward b/c I didn't plan for this)
								var countryID = jurisdictionNode.getAttribute('value').split(":").slice(0,1)[0];
								await Zotero.CachedJurisdictionData.setJurisdictionByIdOrName(countryID);
								var countryName = Zotero.CachedJurisdictionData.jurisdictionNameFromId(countryID).split("|")[0];
								// Splice the name together.
								if (jurisdictionName.match(/^[A-Z][A-Z]\|/)) {
									jurisdictionName = countryName + "|" + jurisdictionName + "|" + jurisdictionStub;
								} else {
									jurisdictionName = jurisdictionName + "|" + jurisdictionStub;
								}
								// Get the ID from the full (searchable) jurisdiction name
								var jurisdictionID = await Zotero.CachedJurisdictionData.setJurisdictionByIdOrName(jurisdictionName);
								// Set the ID in the record, and update the UI
								await this.setJurisdictionKey(jurisdictionID);
							}
						}
					}
					var tabindex = node.getAttribute("ztabindex");
					
					valueElement.setAttribute("id","court-menu");
					valueElement.setAttribute("ztabindex", tabindex);
					valueElement.setAttribute("flex","1");
					valueElement.classList.add("zotero-clicky");
					valueElement.setAttribute("onclick","document.getBindingParent(this).showCourtEditor(this);");
					valueElement.setAttribute("value",result.comment);
					valueElement.setAttribute("label",result.val);
					valueElement.setAttribute("tooltiptext",result.val);
					if (nonMatchHighlight) {
						valueElement.classList.add('yellow');
					}
					node.parentNode.replaceChild(valueElement,node);
					this.item.setField("court",result.comment);
					if (this._tabDirection) {
						var focusBox = this._dynamicFields;
						this._focusNextField(focusBox, this._lastTabIndex, this._tabDirection == -1);
					}
					if (this.saveOnEdit) {
						await this.item.saveTx();
					}
				}.bind(this))();
				]]>
				</body>
			</method>


			<method name="handleJurisdictionAutoCompleteSelect">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
					var result = false;
					var controller = textbox.controller;
					if (!controller.matchCount) return;

					for (var i=0; i<controller.matchCount; i++) {
						if (controller.getValueAt(i) == textbox.value) {
							result = {val:controller.getValueAt(i),comment:controller.getCommentAt(i)};
							break;
						}
					}
					textbox.mController.input = null;
					this.hideJurisdictionEditor(textbox, result);
				]]>
				</body>
			</method>

			<method name="handleCourtAutoCompleteSelect">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
					// Enables save of non-match text
					var result = false;
					var nonMatchHighlight = false;
					var controller = textbox.controller;
					var searchString = controller.searchString;
					if (!controller.matchCount) {
						result = {val:searchString, comment:searchString};
						nonMatchHighlight = true;
					} else {
						for (var i=0; i<controller.matchCount; i++) {
							if (controller.getValueAt(i) == textbox.value) {
								result = {val:controller.getValueAt(i),comment:controller.getCommentAt(i)};
								break;
							}
						}
					}
					if (!result && searchString) {
						result = {val:searchString, comment:searchString};
						nonMatchHighlight = true;
					}
					textbox.mController.input = null;
					this.hideCourtEditor(textbox, result, nonMatchHighlight);
			]]>
				</body>
			</method>

			<method name="createValueElement">
				<parameter name="valueText"/>
				<parameter name="fieldName"/>
				<parameter name="tabindex"/>
				<parameter name="isMulti"/>
				<body>
				<![CDATA[
					valueText = valueText + '';
					
					if (fieldName) {
						var fieldID = Zotero.ItemFields.getID(fieldName);
					}
					
					// If an abstract, check last expand state
					var abstractAsVbox = fieldName == 'abstractNote' && Zotero.Prefs.get('lastAbstractExpand');
					
					// Use a vbox for multiline fields (but Abstract only if it's expanded)
					var useVbox = (fieldName != 'abstractNote' || abstractAsVbox)
						&& Zotero.ItemFields.isMultiline(fieldName);
					
					if (!isMulti && fieldName === 'jurisdiction') {
						var valueElement = document.createElement("menulist");
						valueElement.setAttribute("id","jurisdiction-menu");

						// Set default here if req.
						this.forceJurisdiction(this.item.itemTypeID);
						var value = this.item.getField("jurisdiction",true);
						if (value) {
							var label = Zotero.CachedJurisdictionData.jurisdictionNameFromId(value);
							if (!label) {
								label = value;
								valueElement.classList.add('yellow');
							} else {
								label = label.split("|");
								//if (label.length > 2) {
								//	label = label.slice(1).join("|");
								//} else {
									label = label.join("|");
								//}
							}
							valueElement.setAttribute("label", label);
							valueElement.setAttribute("value", value);
						}
					}
					else if (!isMulti && fieldName === 'court') {
						var valueElement = document.createElement("menulist");
						valueElement.setAttribute("id","court-menu");
						var jurisdictionValue = this.item.getField("jurisdiction",true);
						var value = this.item.getField("court",true);
						if (jurisdictionValue && value) {
							var label = Zotero.CachedJurisdictionData.courtNameFromId(jurisdictionValue, value, true);

							if (!label) {
								label = value;
								// Double-check for validity - may contain a correct court name string
								// on upgrade or immediately after data import
								if (!Zotero.CachedJurisdictionData.courtIdFromName(jurisdictionValue, value, true)) {
								    valueElement.classList.add('yellow');
								}
							}
							valueElement.setAttribute("label", label);
							valueElement.setAttribute("value", value);
						}
					}
					else if (useVbox) {
						var valueElement = document.createElement("vbox");
					}
					else {
						var valueElement = document.createElement("label");
					}
					
					valueElement.setAttribute('fieldname', fieldName);
					valueElement.setAttribute('flex', 1);
					
					if (this._fieldIsClickable(fieldName)) {
						valueElement.setAttribute('ztabindex', tabindex);
						if (!(!isMulti && (fieldName === 'jurisdiction' || fieldName === 'court'))) {
						valueElement.addEventListener('click', function (event) {
							/* Skip right-click on Windows */
							if (event.button) {
								return;
							}
							document.getBindingParent(this).clickHandler(this);
						}, false);
						}
						valueElement.classList.add('zotero-clicky');
					}
					
					switch (fieldName) {
						case 'jurisdiction':
							if (!isMulti) {
								valueElement.setAttribute("onclick","document.getBindingParent(this).showJurisdictionEditor(this);");
								return valueElement;
							}
							break;
							
						case 'court':
							if (!isMulti) {
								valueElement.setAttribute("onclick","document.getBindingParent(this).showCourtEditor(this);");
								return valueElement;
							}
							break;

						case 'itemType':
							valueElement.setAttribute('itemTypeID', valueText);
							valueText = Zotero.ItemTypes.getLocalizedString(valueText);
							break;
						
						// Convert dates from UTC
						case 'dateAdded':
						case 'dateModified':
						case 'accessDate':
						case 'date':
						
						// TEMP - NSF
						case 'dateSent':
						case 'dateDue':
						case 'accepted':
							if (fieldName == 'date' && this.item._objectType != 'feedItem') {
								break;
							}
							if (valueText) {
								var date = Zotero.Date.sqlToDate(valueText, true);
								if (date) {
									// If no time, interpret as local, not UTC
									if (Zotero.Date.isSQLDate(valueText)) {
										date = Zotero.Date.sqlToDate(valueText);
										valueText = date.toLocaleDateString();
									}
									else {
										valueText = date.toLocaleString();
									}
								}
								else {
									valueText = '';
								}
							}
							break;
					}
					
					if (fieldID) {
						// Display the SQL date as a tooltip for date fields
						// TEMP - filingDate
						if (Zotero.ItemFields.isFieldOfBase(fieldID, 'date') || fieldName == 'filingDate') {
							valueElement.setAttribute('tooltiptext',
								Zotero.Date.multipartToSQL(this.item.getField(fieldName, true)));
						}
						
						// Display a context menu for certain fields
						if (this.editable && (fieldName == 'seriesTitle' || fieldName == 'shortTitle' ||
								Zotero.ItemFields.isFieldOfBase(fieldID, 'title') ||
								Zotero.ItemFields.isFieldOfBase(fieldID, 'publicationTitle'))) {
							valueElement.setAttribute('contextmenu', 'zotero-field-transform-menu');
						}
					}
					
					
					if (fieldName && fieldName.indexOf('firstName') != -1) {
						valueElement.setAttribute('flex', '1');
					}
					
					var firstSpace = valueText.indexOf(" ");
					
					// To support newlines in Abstract and Extra fields, use multiple
					// <description> elements inside a vbox
					if (useVbox) {
						var lines = valueText.split("\n");
						for (var i = 0; i < lines.length; i++) {
							var descriptionNode = document.createElement("description");
							// Add non-breaking space to empty lines to prevent them from collapsing.
							// (Just using CSS min-height results in overflow in some cases.)
							if (lines[i] === "") {
								lines[i] = "\u00a0";
							}
							var linetext = document.createTextNode(lines[i]);
							descriptionNode.appendChild(linetext);
							valueElement.appendChild(descriptionNode);
						}
					}
					// 29 == arbitrary length at which to chop uninterrupted text
					else if ((firstSpace == -1 && valueText.length > 29 ) || firstSpace > 29
						|| (fieldName &&
							(fieldName.substr(0, 7) == 'creator') || fieldName == 'abstractNote')) {
						if (fieldName == 'abstractNote') {
							valueText = valueText.replace(/[\t\n]/g, ' ');
						}
						valueElement.setAttribute('crop', 'end');
						valueElement.setAttribute('value',valueText);
						valueElement.value = valueText;
					}
					else {
						// Wrap to multiple lines
						valueElement.appendChild(document.createTextNode(valueText));
					}
					
					// Allow toggling non-editable Abstract open and closed with click
					if (fieldName == 'abstractNote' && !this.editable) {
						valueElement.classList.add("pointer");
						valueElement.addEventListener('click', function () {
							this.toggleAbstractExpand(valueElement.previousSibling, valueElement);
						}.bind(this));
					}
					
					return valueElement;
				]]>
				</body>
			</method>
			
			
			<method name="removeCreator">
				<parameter name="index"/>
				<parameter name="labelToDelete"/>
				<body>
				<![CDATA[
					// Are you multi?
					isMulti = labelToDelete.parentNode.classList.contains('multi');
					// If unsaved row, just remove element
					if (!this.item.hasCreatorAt(index)) {
						labelToDelete.parentNode.removeChild(labelToDelete);
						
						// Enable the "+" button on the previous row
						var elems = this._dynamicFields.getElementsByAttribute('value', '+');
						var button = elems[elems.length-1];
						var creatorFields = this.getCreatorFields(Zotero.getAncestorByTagName(button, 'row'));
						this._enablePlusButton(button, creatorFields.creatorTypeID, creatorFields.fieldMode);
						
						if (!isMulti) {
							this._creatorCount--;
						}
						return;
					}
					// Block delete if there are multilingual variants
					if (isMulti) {
						var langTag = labelToDelete.firstChild.getAttribute("zlang");
						var creator = Zotero.Creators.cleanData(this.item.getCreator(index), true);
                        delete creator.multi._key[langTag];
                        this.item.setCreator(index, creator, creator.creatorTypeID);
					} else {
						if (!(labelToDelete.nextSibling && labelToDelete.nextSibling.tagName === 'rows')) {
							this.item.removeCreator(index);
						}
					}
					this.item.saveTx();
				]]>
				</body>
			</method>
			
			
			<method name="showEditor">
				<parameter name="elem"/>
				<body><![CDATA[
				return (async function () {
					Zotero.debug(`Showing editor for ${elem.getAttribute('fieldname')}`);
					
					var lastTabIndex = this._lastTabIndex = parseInt(elem.getAttribute('ztabindex'));
					
					// If a field is open, hide it before selecting the new field, which might
					// trigger a refresh
					var activeField = this._dynamicFields.querySelector('textbox');
					if (activeField) {
						this._refreshed = false;
						await this.blurOpenField();
						this._lastTabIndex = lastTabIndex;
						// If the box was refreshed, the clicked element is no longer valid,
						// so just focus by tab index
						if (this._refreshed) {
							this._focusNextField(this._lastTabIndex);
							return;
						}
					}
					
					// In Firefox 45, when clicking a multiline field such as Extra, the event is
					// triggered on the inner 'description' element instead of the 'vbox'.
					if (elem.tagName == 'description') {
						elem = elem.parentNode;
					}
					
					var fieldName = elem.getAttribute('fieldname');
					var tabindex = elem.getAttribute('ztabindex');
					
					var row = Zotero.getAncestorByTagName(elem, 'row');
					var label = row.firstChild;
					var langTag = label.getAttribute('zlang');
					var isMulti = false;
					if (row.parentNode.classList.contains('multi')) {
						isMulti = true;
					}

					var [field, creatorIndex, creatorField] = fieldName.split('-');
					if (field == 'creator') {
						var value = this.item.getCreator(creatorIndex);
						if (value) {
							if (isMulti) {
								if (value.multi._key[langTag]) {
									value = value.multi._key[langTag][creatorField];
								} else {
									value = value[creatorField];
								}
							} else {
        	                    value = value[creatorField];
            	            }
						}
						if (value === false) {
							value = "";
						}
						var itemID = this.item.id;
					}
					else {
						var value = this.item.getField(fieldName, null, null, langTag);
						// This ordinary showEditor() function will run on jurisdiction
						// and court only when adding or editing a multilingual variant
						// Use human-readable form for jurisdictions and court names
						if (fieldName === 'jurisdiction') {
							value = Zotero.CachedJurisdictionData.jurisdictionNameFromId(value, true);
						} else if (fieldName === 'court') {
							var jurisdictionID = this.item.getField('jurisdiction', true);
							value = Zotero.CachedJurisdictionData.courtNameFromId(jurisdictionID, value, true);
						}
						
						var itemID = this.item.id;
						
						// Access date needs to be converted from UTC
						if (value != '') {
							switch (fieldName) {
								case 'accessDate':
								
								// TEMP - NSF
								case 'dateSent':
								case 'dateDue':
								case 'accepted':
									// If no time, interpret as local, not UTC
									if (Zotero.Date.isSQLDate(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
									}
									else {
										var localDate = Zotero.Date.sqlToDate(value, true);
									}
									var value = Zotero.Date.dateToSQL(localDate);
									
									// Don't show time in editor
									value = value.replace(' 00:00:00', '');
									break;
							}
						}
					}
					
					var t = document.createElement("textbox");
					t.setAttribute('value', value);
					t.setAttribute('fieldname', fieldName);
					t.setAttribute('ztabindex', tabindex);
					t.setAttribute('flex', '1');
					
					if (creatorField=='lastName') {
						t.setAttribute('fieldMode', elem.getAttribute('fieldMode'));
						t.setAttribute('newlines','pasteintact');
					}
					
					if (Zotero.ItemFields.isMultiline(fieldName) || Zotero.ItemFields.isLong(fieldName)) {
						t.setAttribute('multiline', true);
						t.setAttribute('rows', 8);
					}
					else {
						// Add auto-complete for certain fields
						if (Zotero.ItemFields.isAutocompleteField(fieldName)
								|| fieldName == 'creator') {
							t.setAttribute('type', 'autocomplete');
							t.setAttribute('autocompletesearch', 'jurism');
							
							let params = {
								fieldName: fieldName,
								libraryID: this.item.libraryID
							};
							if (field == 'creator') {
								params.fieldMode = parseInt(elem.getAttribute('fieldMode'));
								
								// Include itemID and creatorTypeID so the autocomplete can
								// avoid showing results for creators already set on the item
								let row = Zotero.getAncestorByTagName(elem, 'row');
								let creatorTypeID = parseInt(
									row.getElementsByClassName('creator-type-label')[0]
									.getAttribute('typeid')
								);
								if (itemID) {
									params.itemID = itemID;
									params.creatorTypeID = creatorTypeID;
								}
								
								// Return
								t.setAttribute('ontextentered',
									'document.getBindingParent(this).handleCreatorAutoCompleteSelect(this, true)');
								// Tab/Shift-Tab
								t.setAttribute('onchange',
									'document.getBindingParent(this).handleCreatorAutoCompleteSelect(this)');
							};
							t.setAttribute(
								'autocompletesearchparam', JSON.stringify(params)
							);
							t.setAttribute('completeselectedindex', true);
						}
					}
					var box = elem.parentNode;
					box.replaceChild(t, elem);
					
					// Prevent error when clicking between a changed field
					// and another -- there's probably a better way
					if (!t.select) {
						return;
					}
					
					t.select();
					
					// Leave text field open when window loses focus
					var ignoreBlur = function () {
						this.ignoreBlur = true;
					}.bind(this);
					var unignoreBlur = function () {
						this.ignoreBlur = false;
					}.bind(this);
					addEventListener("deactivate", ignoreBlur);
					addEventListener("activate", unignoreBlur);
					
					t.addEventListener('blur', function () {
						var self = document.getBindingParent(this);
						if (self.ignoreBlur) return;
						
						removeEventListener("deactivate", ignoreBlur);
						removeEventListener("activate", unignoreBlur);
						self.blurHandler(this);
					});
					t.setAttribute('onkeydown', "return document.getBindingParent(this).handleKeyDown(event)");
					t.setAttribute('onkeypress', "return document.getBindingParent(this).handleKeyPress(event)");
					
					return t;
				}.bind(this))();
				]]></body>
			</method>
			
			
			<!--
			 Save a multiple-field selection for the creator autocomplete
			 (e.g. "Shakespeare, William")
			-->
			<method name="handleCreatorAutoCompleteSelect">
				<parameter name="textbox"/>
				<parameter name="stayFocused"/>
				<body><![CDATA[
					var comment = false;
					var controller = textbox.controller;
					if (!controller.matchCount) return;
					
					for (var i=0; i<controller.matchCount; i++)
					{
						if (controller.getValueAt(i) == textbox.value)
						{
							comment = controller.getCommentAt(i);
							break;
						}
					}
					
					// No result selected
					if (!comment) {
						return;
					}
					
					var [creatorID, numFields] = comment.split('-');
					
					// If result uses two fields, save both
					if (numFields==2)
					{
						// Manually clear autocomplete controller's reference to
						// textbox to prevent error next time around
						textbox.mController.input = null;
						
						var [field, creatorIndex, creatorField] =
							textbox.getAttribute('fieldname').split('-');
						
						if (stayFocused) {
							this._lastTabIndex = parseInt(textbox.getAttribute('ztabindex')) - 1;
							this._tabDirection = 1;
						}
						
						var creator = Zotero.Creators.get(creatorID);
						
						var otherField = creatorField == 'lastName' ? 'firstName' : 'lastName';
						
						// Update this textbox
						textbox.setAttribute('value', creator[creatorField]);
						textbox.value = creator[creatorField];
						
						// Update the other label
						if (otherField=='firstName'){
							var label = textbox.nextSibling.nextSibling;
						}
						else if (otherField=='lastName'){
							var label = textbox.previousSibling.previousSibling;
						}
						
						//this._setFieldValue(label, creator[otherField]);
						if (label.firstChild){
							label.firstChild.nodeValue = creator[otherField];
						}
						else {
							label.value = creator[otherField];
						}
						
						var row = Zotero.getAncestorByTagName(textbox, 'row');
						var langTag = row.firstChild.getAttribute("zlang");
						var isMulti = false;
						if (row.parentNode.classList.contains('multi')) {
							isMulti = true;
						}
						var fields = this.getCreatorFields(row);
						fields[creatorField] = creator[creatorField];
						fields[otherField] = creator[otherField];
						
						this.modifyCreator(creatorIndex, fields, langTag, isMulti);
						if (this.saveOnEdit) {
							this.ignoreBlur = true;
							this.item.saveTx().then(() => {
								this.ignoreBlur = false;
							});
						}
					}
					
					// Otherwise let the autocomplete popup handle matters
				]]>
				</body>
			</method>
			
			<method name="getNameParticleVariants">
			  <parameter name="lastNameValue"/>
			  <parameter name="firstNameValue"/>
			  <body>
				<![CDATA[
					function splitParticles(nameValue, firstNameFlag, caseOverride) {
						// Parse particles out from name fields.
						// * nameValue (string) is the field content to be parsed.
						// * firstNameFlag (boolean) parse trailing particles
						//	 (default is to parse leading particles)
						// * caseOverride (boolean) include all but one word in particle set
						//	 (default is to include only words with lowercase first char)
						// Returns an array with:
						// * (boolean) flag indicating whether a particle was found
						// * (string) the name after removal of particles
						// * (array) the list of particles found
						var origNameValue = nameValue;
						nameValue = caseOverride ? nameValue.toLowerCase() : nameValue;
						var particleList = [];
						var apostrophe;
						if (firstNameFlag) {
							apostrophe ="\u02bb";
							nameValue = nameValue.split("").reverse().join("");
						} else {
							apostrophe ="-\u2019";
						}
						var rex = new RegExp("^([^ ]+[" + apostrophe + " \'] *)(.+)$");
						var m = nameValue.match(rex);
						while (m) {
							var m1 = firstNameFlag ? m[1].split("").reverse().join("") : m[1];
							var firstChar = m ? m1 : false;
							var firstChar = firstChar ? m1.replace(/^[-\'\u02bb\u2019\s]*(.).*$/, "$1") : false;
							var hasParticle = firstChar ? firstChar.toUpperCase() !== firstChar : false;
							if (!hasParticle) break;
							if (firstNameFlag) {
								particleList.push(origNameValue.slice(m1.length * -1));
								origNameValue = origNameValue.slice(0,m1.length * -1);
							} else {
								particleList.push(origNameValue.slice(0,m1.length));
								origNameValue = origNameValue.slice(m1.length);
							}
							//particleList.push(m1);
							nameValue = m[2];
							m = nameValue.match(rex);
						}
						if (firstNameFlag) {
							nameValue = nameValue.split("").reverse().join("");
							particleList.reverse();
							for (var i=1,ilen=particleList.length;i<ilen;i++) {
								if (particleList[i].slice(0, 1) == " ") {
									particleList[i-1] += " ";
								}
							}
							for (var i=0,ilen=particleList.length;i<ilen;i++) {
								if (particleList[i].slice(0, 1) == " ") {
									particleList[i] = particleList[i].slice(1);
								}
							}


							nameValue = origNameValue.slice(0, nameValue.length);
						} else {
							nameValue = origNameValue.slice(nameValue.length * -1);
						}
						return [hasParticle, nameValue, particleList];
					}
					
					function makeUppercase(str) {
						// Set the first case-sensitive character in a string to uppercase
						// * str (string) the string to modify
						// Returns the modified string
						for (var i=0,ilen=str.length;i<ilen;i++) {
							var strChar = str.slice(i,i+1);
							if (strChar.toUpperCase()  !== strChar) {
								str = str.slice(0, i) + strChar.toUpperCase() + str.slice(i+1);
								break;
							}
						}
						return str;
					}
					
					function addTerminalSpace(particles) {
						// Adds a space to the last term in an array, if its last character is not space, apostrophe, or hyphen.
						// * particles (array)
						// Returns undefined. The array is modified in place.
						// This function is idempotent.
						if (particles.length && ["-", "'", "\u2019", " "].indexOf(particles.slice(-1)[0].slice(-1)) == -1) {
							particles[particles.length-1] = particles.slice(-1)[0] + " ";
						}
					}
					
					function joinParticles(sets, forceLowerCase) {
						// Joins particle arrays into a single array
						// (A particle array is an array of strings)
						// * sets (array) an array of particle arrays
						// Returns a single array. Particle arrays given as input are unaffected.
						var particles = [];
						for (var i=0,ilen=sets.length;i<ilen;i++) {
							particles[i] = sets[i].slice();
						}
						for (var i=particles.length-1;i>0;i--) {
							addTerminalSpace(particles[i-1]);
							particles[i-1] = particles[i-1].concat(particles[i]);
						}
						if (particles.length == 0) {
							return [];
						} else {
							if (forceLowerCase) {
								return [for (particle of particles[0]) particle.toLowerCase()];
							} else {
								return particles[0];
							}
						}
					}
					
					// Last-name quote validation
					// (1) lastName must either have quotes start and end, or none at either end.
					var mQuoted = lastNameValue.match(/^(?:\".*\")$/);
					var mUnquoted = lastNameValue.match(/^(?:[^\"].*[^\"])$/);
					if (!mQuoted && !mUnquoted) return false;
					
					
					// Normalize
					// (2) Strip quotes from lastName, eliminate duplicate spaces on both fields
					if (mQuoted) {
						lastNameValue = lastNameValue.slice(1,-1);
					}
					lastNameValue = lastNameValue.replace(/  */g, " ");
					firstNameValue = firstNameValue.replace(/  */g, " ");
					
					// (3) Split particle arrays from fields and compose as an array
					var [hasLastParticle, lastNameValue, lastParticles] = splitParticles(lastNameValue);
					var [hasFirstParticle, firstNameValue, firstParticles] = splitParticles(firstNameValue, true);
					var coreParticles = joinParticles([firstParticles, lastParticles], true);
					
					// (4) Split particle arrays from respective fields with caseOverride option
					var [dummy, lastNameValue, lastExtras] = splitParticles(lastNameValue, false, true);
					var [dummy, firstNameValue, firstExtras] = splitParticles(firstNameValue, true, true);
					
					// (5) Compose particle and name data for each possible set of particles
					var particleSets = [];
					var lastExtrasOrig = lastExtras.slice();
					var firstExtrasOrig = firstExtras.slice();
					while (true) {
						particleSets.push({
							firstRemainder: firstExtrasOrig.slice(0, firstExtrasOrig.length-firstExtras.length),
							lastRemainder: lastExtrasOrig.slice(lastExtras.length),
							particles: joinParticles([firstExtras, coreParticles, lastExtras], true)
						});
						while (lastExtras.length) {
							lastExtras.pop();
							particleSets.push({
								firstRemainder: firstExtrasOrig.slice(0, firstExtrasOrig.length-firstExtras.length),
								lastRemainder: lastExtrasOrig.slice(lastExtras.length),
								particles: joinParticles([firstExtras, coreParticles, lastExtras], true)
							});
						}
						if (!firstExtras.length) break;
						lastExtras = lastExtrasOrig.slice();
						firstExtras.pop();
					}
					
					// (6) Sort particle sets in descending order of list length
					particleSets.sort(function(a,b){
						if (a.particles.length < b.particles.length) {
							return 1;
						} else if (a.particles.length > b.particles.length) {
							return -1;
						} else {
							return 0;
						}
					});
					
					// (7) Try data against list of known particles
					var particles = coreParticles;
					var particleSpec = false;
					for (var i=0,ilen=particleSets.length;i<ilen;i++) {
						var tryParticles = particleSets[i].particles;
						var tryParticleSpec = Zotero.Utilities.nameParticleParse(tryParticles.join("").trim());
						if (tryParticleSpec) {
							particles = tryParticles;
							particleSpec = tryParticleSpec;
							firstNameValue = joinParticles([[firstNameValue],particleSets[i].firstRemainder]).join("");
							lastNameValue = joinParticles([particleSets[i].lastRemainder,[lastNameValue]]).join("");
							break;
						}
					}
					if (!particleSpec) {
						firstNameValue = joinParticles([[firstNameValue],firstExtrasOrig]).join("");
						lastNameValue = joinParticles([lastExtrasOrig,[lastNameValue]]).join("");
					}
					
					// Content of the particles array will be:
					//
					// * If a list match is found above, the matched particles PLUS a particleSpec 
					//   describing possible field allocations
					//
					// * Otherwise if core (lowercase) particles are found, the lowercase particles
					//   with a null particleSpec
					//
					// * Otherwise an empty array.
					
					// (8) Generate a list of all plausible uses of the particles to be fitted
					//	 (first/last allocation, upper- and lower-casing, and quoted status)
					
					// There are four possible states for each particle:
					//
					// 1. Last-name field, lowercase
					// 2. Last-name field, uppercase
					// 3. First-name field, lowercase
					// 4. first-name field, uppercase [assumed to be not desired]
					//
					// In addition, last-name field may be quoted or unquoted
					
					
					// (9) Express particle states as a base-4 integer, one byte per particle
					var base4max = [for (i of particles) "0"];
					base4max = "1" + base4max.join("");
					var combos = [];
					for (i=0,ilen=parseInt(base4max, 4);i<ilen;i++) {
						combos.push(i.toString(4));
					};
					// Pad the 4-byte integer strings
					for (var i=0,ilen=combos.length;i<ilen;i++) {
						while (combos[i].length < (base4max.length-1)) {
							combos[i] = "0" + combos[i];
						}
					}
					// Drop meaningless field states (1 or 0 following 2 or 3)
					for (var i=combos.length-1;i>-1;i--) {
						if (combos[i].match(/[2,3].*[0,1]/)) {
							combos = combos.slice(0,i).concat(combos.slice(i+1));
						}
					}
					// Drop all uppercase dropping particles (3) [see above]
					for (var i=combos.length-1;i>-1;i--) {
						if (combos[i].match(/3/)) {
							combos = combos.slice(0,i).concat(combos.slice(i+1));
						}
					}
					// Uppercase adjustments
					if (!particleSpec) {
						// Drop all uppercase options if unspecified particles
						for (var i=combos.length-1;i>-1;i--) {
							if (combos[i].match(/1/)) {
								combos = combos.slice(0,i).concat(combos.slice(i+1));
							}
						}
					} else {
						// Among uppercase variants, allow only (a) first-only uppercase; or (b) all-uppercase.
						for (var i=combos.length-1;i>-1;i--) {
							if (combos[i].match(/1/)) {
								if (combos[i].match(/^11*$/)) continue;
								if (combos[i].match(/^10*$/)) continue;
								combos = combos.slice(0,i).concat(combos.slice(i+1));
							}
						}
					}

					// (10) Add quote state, only where last-name field has leading lowercase particle
					if (combos.length > 1) {
						for (var i=combos.length-1;i>-1;i--) {
							if (combos[i].slice(0, 1) === "0") {
								combos = combos.slice(0, i).concat(["0" + combos[i], "1" + combos[i]]).concat(combos.slice(i+1));
							} else {
								combos[i] = "0" + combos[i];
							}
						}
						// Add category sort key
						for (var i=combos.length-1;i>-1;i--) {
							// 4 is non-dropping
							// 5 is dropping
							// 6 is no particles
							// 7 is fixed surname
							if (combos[i].slice(0, 1) == 1) {
								combos[i] = "7" + combos[i];
							} else if (combos[i].match(/^.1[0-1]*$/)) {
								combos[i] = "6" + combos[i];
							} else if (combos[i].match(/^.0/)) {
								combos[i] = "4" + combos[i];
							} else {
								combos[i] = "5" + combos[i];
							}
						}
						
						// (11) Group non-dropping, dropping, and fixed-name states
						combos.sort(function(a,b){
							a = parseInt(a.replace(/[23]/, "0"));
							b = parseInt(b.replace(/[23]/, "0"));
							if (a > b) {
								return 1;
							} else if (a < b) {
								return -1;
							} else {
								return 0;
							}
						});
					}
					
					
					// (12) Express the states as particle lists
					var lastCategory = null;
					var particleSets = [];
					for (var i=0,ilen=combos.length;i<ilen;i++) {
						var useMe = true;
						var lastParticleSet = [];
						var firstParticleSet = [];
						var useQuotes = parseInt(combos[i].slice(1, 2));
						var m = combos[i].slice(2).match(/^([0-1]*)(.*)$/);
						if (m[1]) {
							var lastSpec = m[1].split("");
						} else {
							var lastSpec = [];
						}
						if (m[2]) {
							var firstSpec = m[2].split("");
						} else {
							var firstSpec = [];
						}
						for (var j=0,jlen=firstSpec.length;j<jlen;j++) {
							var particle = particles[j];
							if (firstSpec[j] == 3) {
								particle = makeUppercase(particle);
							}
							firstParticleSet.push(particle);
						}
						for (var j=0,jlen=lastSpec.length;j<jlen;j++) {
							var pos = firstParticleSet.length + j;
							var particle = particles[pos];
							if (lastSpec[j] == 1) {
								particle = makeUppercase(particle);
							}
							lastParticleSet.push(particle);
						}
						
						// If particleSpec exists, skip known particle sets with an unknown field allocation pattern
						if (particleSpec) {
							useMe = false;
							for (var j=particleSpec.length-1;j>-1;j--) {
								var spec = particleSpec[j];
								var firstLen = spec[0] ? spec[0][1] - spec[0][0] : 0;
								var lastLen = spec[1] ? spec[1][1] - spec[1][0] : 0;
								if (firstParticleSet.length === firstLen && lastParticleSet.length === lastLen) {
									useMe = true;
									break;
								}
							}
						}
						if (!useMe) continue;
						
						// If heading transition, add the heading
						if (combos[i].slice(0, 1) > 3) {
							var category = combos[i].slice(0, 1);
							if (category != lastCategory) {
								switch (category) {
								case "4":
									particleSets.push([Zotero.getString('pane.item.creatorTransform.nonDroppingParticle')]);
									break;
								case "5":
									particleSets.push([Zotero.getString('pane.item.creatorTransform.droppingParticle')]);
									break;
								case "6":
									particleSets.push([Zotero.getString('pane.item.creatorTransform.noParticle')]);
									break;
								case "7":
									particleSets.push([Zotero.getString('pane.item.creatorTransform.fixedSurname')]);
									break;
								}
							}
							lastCategory = category;
						}
						
						var fieldLastNameValue = joinParticles([lastParticleSet, [lastNameValue]]).join("").trim();
						var fieldFirstNameValue = joinParticles([[firstNameValue], firstParticleSet]).join("").trim();
 						
						var citeVisual = fieldLastNameValue;
						if (useQuotes) {
							var lastVisual = fieldLastNameValue;
							var firstVisual = joinParticles([[firstNameValue], firstParticleSet]).join("");
							fieldLastNameValue = '"' + fieldLastNameValue + '"';
						} else {
							var lastVisual = lastNameValue;
							var pos = lastSpec.indexOf("1");
							if (pos > -1) {
								lastVisual = joinParticles([lastParticleSet.slice(pos), [lastVisual]]).join("");
								lastParticleSet = lastParticleSet.slice(0, pos);
							}
							var firstVisual = joinParticles([[firstNameValue], firstParticleSet, lastParticleSet]).join("");
						}
						// \u274a = stylized hoshijirushi
						// \u274b = stylized hoshijirushi simple bold
						// \u2749 = stylized hoshijirushi bolder styled-er
						// \uff0a = asterisk
						// \u205c = komejirushi
						// \u2733 = sans serif stylized asterisk;
						// \u2b24 = big black circle;
						// \u25cf = black circle;
						// \u2b1c = big white square;
						// \u2b04 = double arrow;
						composedVisual = "(" + citeVisual + ") \u274b " + [lastVisual, firstVisual].join(", ");
						
						particleSets.push([fieldLastNameValue, fieldFirstNameValue, composedVisual]);
					}
					
					// (13) VoilÃ 
					return particleSets;
				]]>
			  </body>
			</method>


			<method name="checkNameParticleVariants">
			  <parameter name="menuNode"/>
			  <parameter name="popupNode"/>
			  <body>
				<![CDATA[
					var lastNameValue = popupNode.parentNode.firstChild.value;
					var firstNameValue = popupNode.parentNode.lastChild.value;
					if (lastNameValue === this._defaultLastName) {
						lastNameValue = '';
					}
					if (firstNameValue === this._defaultFirstName) {
						firstNameValue = '';
					}
					var variants = this.getNameParticleVariants(lastNameValue, firstNameValue);
					return [lastNameValue, firstNameValue, variants];
				]]>
			  </body>
			</method>


			<method name="setNameParticleVariant">
			  <parameter name="menuNode"/>
			  <parameter name="popupNode"/>
			  <parameter name="lastNameValue"/>
			  <parameter name="firstNameValue"/>
			  <parameter name="variants"/>
			  <body>
				<![CDATA[
					for (var i=0,ilen=menuNode.childNodes.length;i<ilen;i++) {
						menuNode.removeChild(menuNode.childNodes[0]);
					}
					var saveOnEdit = variants ? true : false;
					if (saveOnEdit) {
						var row = Zotero.getAncestorByTagName(popupNode, 'row');
						var fields = this.getCreatorFields(row);
						var fieldName = popupNode.getAttribute("fieldname");
						var [field, creatorIndex, creatorField] = fieldName.split('-');
						var langTag = row.firstChild.getAttribute('zlang');
						var isMulti = row.parentNode.classList.contains('multi');
					} else {
						var [lastNameValue, firstNameValue, variants] = this.checkNameParticleVariants(menuNode, popupNode);
					}
					var lnNode = popupNode.parentNode.firstChild;
					var fnNode = popupNode.parentNode.lastChild;
					
					for (var i=0,ilen=variants.length;i<ilen;i++) {
						var menuitem = document.createElement('menuitem');
						if (variants[i].length === 1) {
							menuitem.setAttribute('label', variants[i][0]);
							menuitem.setAttribute('class', 'menu-heading');
							menuNode.appendChild(menuitem);
							menuitem.disabled = true;
							continue;
						}
						menuitem.setAttribute('label', variants[i][2]);
						var setNamesHandler;
						if (saveOnEdit) {
							setNamesHandler = function(lnNode, fnNode, lnVal, fnVal) {
								return function() {
									fields.lastName = lnVal;
									fields.firstName = fnVal;
									document.getBindingParent(this).saveOnEdit = true;
									document.getBindingParent(this).modifyCreator(creatorIndex, fields, langTag, isMulti);
									// Save happens, but does not always update UI for some reason
									lnNode.value = lnVal;
									lnNode.setAttribute('value', lnVal);
									fnNode.value = fnVal;
									fnNode.setAttribute('value', fnVal);
								}
							}(lnNode, fnNode, variants[i][0], variants[i][1]);
						} else {
							setNamesHandler = function(lnNode, fnNode, lnVal, fnVal) {
								return function() {
									lnNode.value = lnVal;
									lnNode.setAttribute('value', lnVal);
									fnNode.value = fnVal;
									fnNode.setAttribute('value', fnVal);
								}
							}(lnNode, fnNode, variants[i][0], variants[i][1]);
						}
						menuitem.addEventListener('command', setNamesHandler);
						menuNode.appendChild(menuitem);
					}
					if (variants.length) {
						return true;
					} else {
						return false;
					}
				]]>
			  </body>
			</method>
			
			
			<method name="handleKeyDown">
				<parameter name="event"/>
				<body>
				<![CDATA[
					var target = event.target;
					var focused = document.commandDispatcher.focusedElement;
 					
					switch (event.key)
					{
						case 'i':
							if (event.ctrlKey) {
								event.preventDefault();
								// Apply italics
								var selectionStart = target.selectionStart;
								var selectionEnd = target.selectionEnd;
								if (selectionStart !== selectionEnd) {
									var start = target.value.slice(0,selectionStart);
									var middle = target.value.slice(selectionStart,selectionEnd);
									var end = target.value.slice(selectionEnd);
									if (middle) {
										target.value = (start + '<i>' + middle + '</i>' + end);
									}
								}
								return false;
							}
							break;
						case 'p':
						case 'ArrowLeft':
						case 'ArrowRight':
							if (event.ctrlKey && target.getAttribute('fieldname').slice(0,7) === 'creator') {
								event.preventDefault();
								if (!target.parentNode.lastChild.hidden) {
									var firstName = target.parentNode.lastChild;
									var lastName = target.parentNode.firstChild;
									var firstNameValue = firstName.value;
									var lastNameValue = lastName.value;
									if (lastNameValue === this._defaultLastName) {
										lastNameValue = "";
									}
									if (firstNameValue === this._defaultFirstName) {
										firstNameValue = "";
									}
									// Move to left or right one char at a time
									if (event.keyCode == 37) {
										lastName.setAttribute("value", lastNameValue + firstNameValue.slice(0,1));
										firstName.setAttribute("value", firstNameValue.slice(1));
									} else if (event.keyCode == 39) {
										firstName.setAttribute("value", lastNameValue.slice(-1) + firstNameValue);
										lastName.setAttribute("value", lastNameValue.slice(0,-1));
									}
									// Cycle particle state
									if (event.key == 'p') {
										// Here's where the menu happens.
										
										var popupNode = event.target;
										var menuNode = document.getBindingParent(popupNode)._nameParticlesMenu;
										document.popupNode = popupNode;
										menuNode.openPopup(popupNode, "after_start", 0, 0, false, false);
									}
									if (!firstName.value) {
										firstName.value = this._defaultFirstName;
									}
									if (!lastName.value) {
										lastName.value = this._defaultLastName;
									}
									return false;
								}
							}
							break;
					}
					
					return true;

				]]></body>
			</method>
			
			
			<method name="handleKeyPress">
				<parameter name="event"/>
				<body>
				<![CDATA[
					var target = event.target;
					var focused = document.commandDispatcher.focusedElement;
					
					switch (event.keyCode)
					{

						case event.DOM_VK_RETURN:
							var fieldname = target.getAttribute('fieldname');
							// Use shift-enter as the save action for the larger fields
							if (Zotero.ItemFields.isMultiline(fieldname) && !event.shiftKey) {
								break;
							}
							
							// Prevent blur on containing textbox
							// DEBUG: what happens if this isn't present?
							event.preventDefault();
							
							// Shift-enter adds new creator row
							if (fieldname.indexOf('creator-') == 0 && event.shiftKey) {
								// Value hasn't changed
								if (target.getAttribute('value') == target.value) {
									// If + button is disabled, just focus next creator row
									if (Zotero.getAncestorByTagName(target, 'row').lastChild.lastChild.disabled) {
										this._focusNextField(this._lastTabIndex);
									}
									else {
										var creatorFields = this.getCreatorFields(Zotero.getAncestorByTagName(target, 'row'));
										this.addCreatorRow(false, creatorFields.creatorTypeID, true);
									}
								}
								// Value has changed
								else {
									this._tabDirection = 1;
									this._addCreatorRow = true;
									focused.blur();
								}
								return false;
							}
							focused.blur();
							
							// Return focus to items pane
							var tree = document.getElementById('zotero-items-tree');
							if (tree) {
								tree.focus();
							}
							
							return false;
							
						case event.DOM_VK_ESCAPE:
							// Reset field to original value
							target.value = target.getAttribute('value');
							
							focused.blur();
							
							// Return focus to items pane
							var tree = document.getElementById('zotero-items-tree');
							if (tree) {
								tree.focus();
							}
							
							return false;
							
						case event.DOM_VK_TAB:
							if (event.shiftKey) {
								this._focusNextField(this._lastTabIndex, true);
							}
							else {
								this._focusNextField(++this._lastTabIndex);
							}
							return false;
					}
					
					return true;
				]]>
				</body>
			</method>
			
			
			<method name="itemTypeMenuTab">
				<parameter name="event"/>
				<body>
				<![CDATA[
					if (!event.shiftKey) {
						this.focusFirstField();
						event.preventDefault();
					}
					// Shift-tab
					else {
						this._tabDirection = false;
					}
				]]>
				</body>
			</method>
			

			<method name="jurisdictionMenuTab">
				<parameter name="event"/>
				<body>
				<![CDATA[
					var elem = event.target;
					var ztabindex = elem.getAttribute("ztabindex");
					var tabindex = parseInt(elem.getAttribute("ztabindex"),10);
					if (!event.shiftKey) {
						tabindex += 1;
					} else {
						// Shift-tab
						tabindex += -1;
					}
					var nextelem = this._dynamicFields.getElementsByAttribute("ztabindex",tabindex)[0];
					nextelem.click();
					event.preventDefault();
 				]]>
 				</body>
			</method>
			
			
			<method name="hideEditor">
				<parameter name="textbox"/>
				<body><![CDATA[
				return (async function () {
					Zotero.debug(`Hiding editor for ${textbox.getAttribute('fieldname')}`);
					
					this._lastTabIndex = -1;
					
					// Prevent autocomplete breakage in Firefox 3
					if (textbox.mController) {
						textbox.mController.input = null;
					}
					
					var fieldName = textbox.getAttribute('fieldname');
					var tabindex = textbox.getAttribute('ztabindex');
					
					var value = textbox.value;
					
					var elem;
					var [field, creatorIndex, creatorField] = fieldName.split('-');
					var newVal;
					
					var row = Zotero.getAncestorByTagName(textbox, 'row');
					var isMulti = false;
					var rows = Zotero.getAncestorByTagName(row, 'rows');
					if (rows.classList.contains('multi')) {
					   isMulti = true;
					}
					var fieldLang = row.firstChild.getAttribute('zlang');
					
					if (field !== 'creator' && (!value || !value.trim())) {
						if (isMulti) {
							// XXX Could probably be a little smoother here.
							this.item.setField(fieldName,null,null,fieldLang)
							rows.removeChild(row);
							if (!rows.childNodes.length) {
								rows.parentNode.removeChild(rows);
							}
							this.multiTabUpdate();
							this.item.saveTx();
							return;
						} else if (this.item.multi.langs(field).length) {
							value = this.item.getField(field);
						}
					}

					// Creator fields
					if (field == 'creator') {

					// NEEDS REVAMPERYzzz

						var otherFields = this.getCreatorFields(row);
						otherFields[creatorField] = value;
						var lastName = otherFields.lastName.trim();
						var firstName = otherFields.firstName ? otherFields.firstName.trim() : '';
						
						if (isMulti) {
							if (!lastName && !firstName) {
								delete otherFields.multi._key[fieldLang];
								this.item.setCreator(creatorIndex, otherFields, otherFields.creatorTypeID);
								this.item.saveTx();
								this.refresh(true);
								return;
							}
						}

						//Handle \n\r and \n delimited entries
						var rawNameArray = lastName.split(/\r\n?|\n/);
						if (rawNameArray.length > 1) {
							//Save tab direction and add creator flags since they are reset in the 
							//process of adding multiple authors
							var tabDirectionBuffer = this._tabDirection;
							var addCreatorRowBuffer = this._addCreatorRow;
							var tabIndexBuffer = this._lastTabIndex;
							this._tabDirection = false;
							this._addCreatorRow = false;
							
							//Filter out bad names
							var nameArray = rawNameArray.filter(name => name);
							
							//If not adding names at the end of the creator list, make new creator 
							//entries and then shift down existing creators.
							var initNumCreators = this.item.numCreators();
							var creatorsToShift = initNumCreators - creatorIndex;
							if (creatorsToShift > 0) { 
								//Add extra creators
								for (var i=0;i<nameArray.length;i++) {
									this.modifyCreator(i + initNumCreators, otherFields);
								}
								
								//Shift existing creators
								for (var i=initNumCreators-1; i>=creatorIndex; i--) {
									let shiftedCreatorData = this.item.getCreator(i);
									this.item.setCreator(nameArray.length + i, shiftedCreatorData);
								}
							}
							
							//Add the creators in lastNameArray one at a time
							for (let tempName of nameArray) {
								// Check for tab to determine creator name format
								otherFields.fieldMode = (tempName.indexOf('\t') == -1) ? 1 : 0;
								if (otherFields.fieldMode == 0) {
									otherFields.lastName=tempName.split('\t')[0];
									otherFields.firstName=tempName.split('\t')[1];
								} 
								else {
									otherFields.lastName=tempName;
									otherFields.firstName='';
								}
								this.modifyCreator(creatorIndex, otherFields);
								creatorIndex++;
							}
							this._tabDirection = tabDirectionBuffer;
							this._addCreatorRow = (creatorsToShift==0) ? addCreatorRowBuffer : false;
							if (this._tabDirection == 1) {
								this._lastTabIndex = parseInt(tabIndexBuffer,10) + 2*(nameArray.length-1);
								if (otherFields.fieldMode == 0) {
									this._lastTabIndex++;
								}
							}
						}
						else {
							this.modifyCreator(creatorIndex, otherFields, fieldLang, isMulti);
						}
						
						var val = this.item.getCreator(creatorIndex);
						if (isMulti && val) {
							if (val.multi._key[fieldLang]) {
								val = val.multi._key[fieldLang];
							}
						}
						val = val ? val[creatorField] : null;
						
						if (!val) {
							// Reset to '(first)'/'(last)'/'(name)'
							if (creatorField == 'lastName') {
								val = otherFields.fieldMode
									? this._defaultFullName : this._defaultLastName;
							}
							else if (creatorField == 'firstName') {
								val = this._defaultFirstName;
							}
						}
						
						newVal = val;
						
						// Reset creator mode settings here so that flex attribute gets reset
						this.switchCreatorMode(row, (otherFields.fieldMode ? 1 : 0), true);
						if (Zotero.ItemTypes.getName(this.item.itemTypeID) === "bookSection") {
							var creatorTypeLabels = document.getAnonymousNodes(this)[0].getElementsByClassName("creator-type-label");
							Zotero.debug(creatorTypeLabels[creatorTypeLabels.length-1] + "");
							document.getElementById("zotero-author-guidance").show({
								forEl: creatorTypeLabels[creatorTypeLabels.length-1]
							});
						}
					}
					
					// Fields
					else {
						// Access date needs to be parsed and converted to UTC SQL date
						if (value != '') {
							switch (fieldName) {
								case 'accessDate':
									// Allow "now" to use current time
									if (value == 'now') {
										value = Zotero.Date.dateToSQL(new Date(), true);
									}
									// If just date, don't convert to UTC
									else if (Zotero.Date.isSQLDate(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
										value = Zotero.Date.dateToSQL(localDate).replace(' 00:00:00', '');
									}
									else if (Zotero.Date.isSQLDateTime(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
										value = Zotero.Date.dateToSQL(localDate, true);
									}
									else {
										var d = Zotero.Date.strToDate(value);
										value = null;
										if (d.year && d.month != undefined && d.day) {
											d = new Date(d.year, d.month, d.day);
											value = Zotero.Date.dateToSQL(d).replace(' 00:00:00', '');
										}
									}
									break;
								
								// TEMP - NSF
								case 'dateSent':
								case 'dateDue':
								case 'accepted':
									if (Zotero.Date.isSQLDate(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
										value = Zotero.Date.dateToSQL(localDate).replace(' 00:00:00', '');
									}
									else {
										var d = Zotero.Date.strToDate(value);
										value = null;
										if (d.year && d.month != undefined && d.day) {
											d = new Date(d.year, d.month, d.day);
											value = Zotero.Date.dateToSQL(d).replace(' 00:00:00', '');
										}
									}
									break;
								
								default:
									// TODO: generalize to all date rows/fields
									if (Zotero.ItemFields.isFieldOfBase(fieldName, 'date')) {
										// Parse 'yesterday'/'today'/'tomorrow' and convert to dates,
										// since it doesn't make sense for those to be actual metadata values
										var lc = value.toLowerCase();
										if (lc == 'yesterday' || lc == Zotero.getString('date.yesterday')) {
											value = Zotero.Date.dateToSQL(new Date(new Date().getTime() - 86400000)).substr(0, 10);
										}
										else if (lc == 'today' || lc == Zotero.getString('date.today')) {
											value = Zotero.Date.dateToSQL(new Date()).substr(0, 10);
										}
										else if (lc == 'tomorrow' || lc == Zotero.getString('date.tomorrow')) {
											value = Zotero.Date.dateToSQL(new Date(new Date().getTime() + 86400000)).substr(0, 10);
										}
									}
							}
						}
						
						this._modifyField(fieldName, value, fieldLang, !isMulti);
						newVal = this.item.getField(fieldName);
					}
					
					// Close box
					elem = this.createValueElement(
						newVal,
						fieldName,
						tabindex
					);
					var box = textbox.parentNode;
					box.replaceChild(elem, textbox);
					
					if (this.saveOnEdit) {
						await this.item.saveTx();
					}
				}.bind(this))();
				]]></body>
			</method>
			
			
			<method name="_rowIsClickable">
				<parameter name="fieldName"/>
				<body>
				<![CDATA[
				 	return this.clickByRow &&
						(this.clickable ||
							this._clickableFields.indexOf(fieldName) != -1);
				]]>
				</body>
			</method>
			
			
			<method name="_fieldIsClickable">
				<parameter name="fieldName"/>
				<body>
				<![CDATA[
					return !this.clickByRow &&
						((this.clickable && !Zotero.Items.isPrimaryField(fieldName))
							|| this._clickableFields.indexOf(fieldName) != -1);
				]]>
				</body>
			</method>
			
			<method name="_modifyField">
				<parameter name="field"/>
				<parameter name="value"/>
				<parameter name="lang"/>
				<parameter name="force_top"/>
				<body><![CDATA[
					this.item.setField(field, value, null, lang, force_top);
				]]></body>
			</method>
			
			
			<method name="_getFieldValue">
				<parameter name="label"/>
				<body>
				<![CDATA[
					return label.firstChild
						? label.firstChild.nodeValue : label.value;
				]]>
				</body>
			</method>
			
			
			<method name="_setFieldValue">
				<parameter name="label"/>
				<parameter name="value"/>
				<body>
				<![CDATA[
					if (label.firstChild) {
						label.firstChild.nodeValue = value;
					}
					else {
						label.value = value;
					}
				]]>
				</body>
			</method>
			
			
			<!-- TODO: work with textboxes too -->
			<method name="textTransform">
				<parameter name="label"/>
				<parameter name="mode"/>
				<body><![CDATA[
					return (async function () {
						var val = this._getFieldValue(label);
						var row = Zotero.getAncestorByTagName(label, "row");
						var fieldName = row.firstChild.getAttribute("fieldname");
						var langTag = row.firstChild.getAttribute('zlang');
						var isMulti = row.parentNode.classList.contains('multi');
						switch (mode) {
							case 'title':
								var newVal = Zotero.Utilities.capitalizeTitle(val.toLowerCase(), true);
								break;
							case 'sentence':
								// capitalize the first letter, including after beginning punctuation
								// capitalize after ?, ! and remove space(s) before those as well as colon analogous to capitalizeTitle function
								// also deal with initial punctuation here - open quotes and Spanish beginning punctuation marks
								newVal = val.toLowerCase().replace(/\s*:/, ":");
								newVal = newVal.replace(/(([\?!]\s*|^)([\'\"Â¡Â¿âââÂ«\s]+)?[^\s])/g, function (x) {
									return x.replace(/\s+/m, " ").toUpperCase();});
								break;
							default:
								throw ("Invalid transform mode '" + mode + "' in zoteroitembox.textTransform()");
						}
						this._setFieldValue(label, newVal);
						this._modifyField(label.getAttribute('fieldname'), newVal, langTag, !isMulti);
						if (this.saveOnEdit) {
							// If a field is open, blur it, which will trigger a save and cause
							// the saveTx() to be a no-op
							await this.blurOpenField();
							await this.item.saveTx();
						}
					}.bind(this))();
				]]></body>
			</method>
			
			
			<method name="getCreatorFields">
				<parameter name="row"/>
				<body>
				<![CDATA[
					var typeID = row.getElementsByClassName('creator-type-label')[0].getAttribute('typeid');
					var label1 = row.getElementsByClassName('creator-name-box')[0].firstChild;
					var label2 = label1.parentNode.lastChild;
					
					var fields = {
						lastName: label1.firstChild ? label1.firstChild.nodeValue : label1.value,
						firstName: label2.firstChild ? label2.firstChild.nodeValue : label2.value,
						fieldMode: label1.getAttribute('fieldMode')
							? parseInt(label1.getAttribute('fieldMode')) : 0,
						creatorTypeID: parseInt(typeID),
					};
					
					// Ignore '(first)'
					if (fields.fieldMode == 1 || fields.firstName == this._defaultFirstName) {
						fields.firstName = '';
					}
					// Ignore '(last)' or '(name)'
					if (fields.lastName == this._defaultFullName
							|| fields.lastName == this._defaultLastName) {
						fields.lastName = '';
					}
					
					return fields;
				]]>
				</body>
			</method>
			

			<method name="modifyCreator">
				<parameter name="index"/>
				<parameter name="fields"/>
				<parameter name="langTag"/>
				<parameter name="isMulti"/>
				<body><![CDATA[
					var libraryID = this.item.libraryID;
					var firstName = fields.firstName;
					var lastName = fields.lastName;
					var fieldMode = fields.fieldMode;
					var creatorTypeID = fields.creatorTypeID;
					
					var realOldCreator = this.item.getCreator(index);
					var oldCreator = realOldCreator;
					if (realOldCreator) {
						realOldCreator = Zotero.Creators.cleanData(realOldCreator, true);
						oldCreator = Zotero.Creators.cleanData(realOldCreator);
					}

					if (langTag && isMulti && realOldCreator) {
						oldCreator = realOldCreator.multi._key[langTag];
					}
					
					// Don't save empty creators
					if (!firstName && !lastName){
						if (!oldCreator) {
							return false;
						}
						if (langTag && isMulti) {
							return this.item.removeCreator(index, langTag);
						} else {
							// XXX Use xpath to check if multi creators exist, block if they do.
							var xpath = '*[local-name()="rows" and contains(@class,"creator")][' + (index+1) + ']/*[local-name()="rows" and contains(@class,"multi")]';
							var nodes = document.evaluate(xpath, this._dynamicFields, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
							if (!nodes.snapshotLength) {
								return this.item.removeCreator(index);
							} else {
								return false;
							}
						}
					}
                    
					var creator;
                    if (langTag && isMulti) {
						if (!realOldCreator) {
							throw "In modifyCreator() attempt to set variant on non-existent creator";
						}
						if (!realOldCreator.multi._key[langTag]) {
							realOldCreator.multi._key[langTag] = {};
						}
						realOldCreator.multi._key[langTag].firstName = firstName;
						realOldCreator.multi._key[langTag].lastName = lastName;
						realOldCreator.multi._key[langTag].fieldMode = fields.fieldMode;
						creator = realOldCreator;
					} else {
						if (realOldCreator) {
							realOldCreator.firstName = firstName;
							realOldCreator.lastName = lastName;
							realOldCreator.fieldMode = fields.fieldMode;
							realOldCreator.creatorTypeID = fields.creatorTypeID;
							creator = realOldCreator;
						} else {
							creator = fields;
							creator.multi = {
							  _key: {}
							}
						}
					}
					
					return this.item.setCreator(index, creator);
				]]></body>
			</method>
			
			
			<!--
			  @return {Promise}
			-->
			<method name="swapNames">
				<parameter name="event"/>
				<body><![CDATA[
				return (async function () {
					var row = Zotero.getAncestorByTagName(document.popupNode, 'row');
					var typeBox = row.getElementsByClassName('creator-type-label')[0];
					var creatorIndex = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);
					var fields = this.getCreatorFields(row);
					var langTag = row.firstChild.getAttribute('zlang');
					var isMulti = row.parentNode.classList.contains('multi');
					var lastName = fields.lastName;
					var firstName = fields.firstName;
					fields.lastName = firstName;
					fields.firstName = lastName;
					this.modifyCreator(creatorIndex, fields, langTag, isMulti);
					if (this.saveOnEdit) {
						// See note in transformText()
						await this.blurOpenField();
						await this.item.saveTx();
					}
				}.bind(this))();
				]]></body>
			</method>
			
			<!--
			  @return {Promise}
			-->
			<method name="moveCreator">
				<parameter name="index"/>
				<parameter name="moveUp"/>
				<body><![CDATA[
				return Zotero.spawn(function* () {
					if (index == 0 && moveUp) {
						Zotero.debug("Can't move up creator 0");
						return;
					}
					else if (index + 1 == this.item.numCreators() && !moveUp) {
						Zotero.debug("Can't move down last creator");
						return;
					}
					
					var newIndex = moveUp ? index - 1 : index + 1;
					var a = this.item.getCreator(index);
					var b = this.item.getCreator(newIndex);
					this.item.setCreator(newIndex, a);
					this.item.setCreator(index, b);
					if (this.saveOnEdit) {
						// See note in transformText()
						yield this.blurOpenField();
						return this.item.saveTx();
					}
				}, this);
				]]></body>
			</method>
			
			
			<method name="_updateAutoCompleteParams">
				<parameter name="row"/>
				<parameter name="changedParams"/>
				<body>
				<![CDATA[
					var textboxes = row.getElementsByTagName('textbox');
					if (textboxes.length) {
						var t = textboxes[0];
						var params = JSON.parse(t.getAttribute('autocompletesearchparam'));
						for (var param in changedParams) {
							params[param] = changedParams[param];
						}
						t.setAttribute('autocompletesearchparam', JSON.stringify(params));
					}
				]]>
				</body>
			</method>
			
			
			<method name="focusFirstField">
				<body>
				<![CDATA[
					this._focusNextField(1);
				]]>
				</body>
			</method>
			
			
			<!-- 
				Advance the field focus forward or backward
				
				Note: We're basically replicating the built-in tabindex functionality,
				which doesn't work well with the weird label/textbox stuff we're doing.
				(The textbox being tabbed away from is deleted before the blur()
				completes, so it doesn't know where it's supposed to go next.)
			-->

			<method name="_focusNextField">
				<parameter name="tabindex"/>
				<parameter name="back"/>
				<body>
				<![CDATA[
					var box = this._dynamicFields;
					tabindex = parseInt(tabindex);
					
					// Get all fields with ztabindex attributes
					var tabbableFields = box.querySelectorAll('*[ztabindex]');
					
					if (!tabbableFields.length) {
						Zotero.debug("No tabbable fields found");
						return false;
					}
					
					var next;
					if (back) {
						Zotero.debug('Looking for previous tabindex before ' + tabindex, 4);
						for (let i = tabbableFields.length - 1; i >= 0; i--) {
							if (parseInt(tabbableFields[i].getAttribute('ztabindex')) < tabindex) {
								next = tabbableFields[i];
								break;
							}
						}
					}
					else {
						Zotero.debug('Looking for tabindex ' + tabindex, 4);
						for (var pos = 0; pos < tabbableFields.length; pos++) {
							if (parseInt(tabbableFields[pos].getAttribute('ztabindex')) >= tabindex) {
								next = tabbableFields[pos];
								break;
							}
						}
					}
					
					if (!next) {
						Zotero.debug("Next field not found");
						return false;
					}
					
					next.click();
					
					// 1) next.parentNode is always null for some reason
					// 2) For some reason it's necessary to scroll to the next element when
					// moving forward for the target element to be fully in view
					if (!back && tabbableFields[pos + 1]) {
						Zotero.debug("Scrolling to next field");
						var visElem = tabbableFields[pos + 1];
					}
					else {
						var visElem = next;
					}
					// DEBUG: This doesn't seem to work anymore
					this.ensureElementIsVisible(visElem);
					
					return true;
				]]>
				</body>
			</method>
			
			
			<method name="blurOpenField">
				<body><![CDATA[
					return (async function () {
						var activeField = this._dynamicFields.querySelector('textbox');
						if (!activeField) {
							return false;
						}
						return this.blurHandler(activeField);
					}.bind(this))();
				]]></body>
			</method>
			
			
			<!--
				Available handlers:
				
				  - 'itemtypechange'
				
				Note: 'this' in the function will be bound to the item box.
			-->
			<method name="addHandler">
				<parameter name="eventName"/>
				<parameter name="func"/>
				<body>
				<![CDATA[
					if (!this.eventHandlers[eventName]) {
						this.eventHandlers[eventName] = [];
					}
					this.eventHandlers[eventName].push(func);
				]]>
				</body>
			</method>
			
			<method name="removeHandler">
				<parameter name="eventName"/>
				<parameter name="func"/>
				<body>
				<![CDATA[
					if (!this.eventHandlers[eventName]) {
						return;
					}
					var pos = this.eventHandlers[eventName].indexOf(func);
					if (pos != -1) {
						this.eventHandlers[eventName].splice(pos, 1);
					}
				]]>
				</body>
			</method>
			
			
			<method name="_id">
				<parameter name="id"/>
				<body>
				<![CDATA[
					return document.getAnonymousNodes(this)[0].getElementsByAttribute('id', id)[0];
				]]>
				</body>
			</method>

			<method name="setJurisdictionKey">
			  <parameter name="key"/>
			  <body>
				<![CDATA[
				return (async function () {
					var jurisdictionDefaultNode = document.getElementById('jurisdiction-default');
					if (key && jurisdictionDefaultNode) {
						if (key && key == Zotero.Prefs.get("import.jurisdictionDefault")) {
							jurisdictionDefaultNode.setAttribute("checked",true);
						} else {
							jurisdictionDefaultNode.setAttribute("checked",false);
						}
					}
					this.item.setField("jurisdiction",key);
					return Zotero.CachedJurisdictionData.load(this.item);
				}.bind(this))();
				]]>
			  </body>
			</method>

		</implementation>
		
		<content>
			<scrollbox id="item-box" flex="1" orient="vertical"
				 	xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
				<popupset>
					<menupopup id="creator-type-menu" position="after_start"
						onpopupshowing="var typeBox = document.popupNode.localName == 'hbox' ? document.popupNode : document.popupNode.parentNode;
								var index = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);
								
								var item = document.getBindingParent(this).item;
								var exists = item.hasCreatorAt(index);
								var moreCreators = item.numCreators() > index + 1;
								
								var hideMoveUp = !exists || index == 0;
								var hideMoveDown = !exists || !moreCreators;
								var hideMoveSep = hideMoveUp &amp;&amp; hideMoveDown;
								
								document.getElementById('zotero-creator-move-sep').setAttribute('hidden', hideMoveSep);
								document.getElementById('zotero-creator-move-up').setAttribute('hidden', hideMoveUp);
								document.getElementById('zotero-creator-move-down').setAttribute('hidden', hideMoveDown);"
						oncommand="var typeBox = document.popupNode.localName == 'hbox' ? document.popupNode : document.popupNode.parentNode;
							var index = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);
							
							var itemBox = document.getBindingParent(this);
							
							if (event.explicitOriginalTarget.className == 'zotero-creator-move') {
								var up = event.explicitOriginalTarget.id == 'zotero-creator-move-up';
								itemBox.moveCreator(index, up);
								return;
							}
							
							var typeID = event.explicitOriginalTarget.getAttribute('typeid');
							var row = typeBox.parentNode;
							var fields = itemBox.getCreatorFields(row);
							fields.creatorTypeID = typeID;
							typeBox.getElementsByTagName('label')[0].setAttribute(
								'value',
								Zotero.getString(
									'creatorTypes.' + Zotero.CreatorTypes.getName(typeID)
								)
							);
							typeBox.setAttribute('typeid', typeID);
							
							/* If a creator textbox is already open, we need to
							change its autocomplete parameters so that it
							completes on a creator with a different creator type */
							var changedParams = {
								creatorTypeID: typeID
							};
							itemBox._updateAutoCompleteParams(row, changedParams);
							
							itemBox.modifyCreator(index, fields);
							if (itemBox.saveOnEdit) {
								itemBox.item.saveTx();
							}
							"/>
					<menupopup id="zotero-field-transform-menu">
						<menu label="&zotero.item.textTransform;">
							<menupopup>
								<menuitem label="&zotero.item.textTransform.titlecase;" class="menuitem-non-iconic"
									oncommand="document.getBindingParent(this).textTransform(document.popupNode, 'title')"/>
								<menuitem label="&zotero.item.textTransform.sentencecase;" class="menuitem-non-iconic"
									oncommand="document.getBindingParent(this).textTransform(document.popupNode, 'sentence')"/>
							</menupopup>
						</menu>
					</menupopup>
					<menupopup id="zotero-creator-transform-menu"
						onpopupshowing="var row = Zotero.getAncestorByTagName(document.popupNode, 'row');
							var typeBox = row.getElementsByClassName('creator-type-label')[0];
							var index = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);
							var item = document.getBindingParent(this).item;
							var exists = item.hasCreatorAt(index);
							if (exists) {
								var fieldMode = item.getCreator(index).name !== undefined ? 1 : 0;
							}
							var hideTransforms = !exists || !!fieldMode;
							if (!hideTransforms) {
								var [lastNameValue, firstNameValue, variants] = document.getBindingParent(this).checkNameParticleVariants(this, document.popupNode);
								var particlesMenuNode = document.getElementById('name-particles-menu');
								if (variants.length > 1) {
									particlesMenuNode.disabled = false;
									document.getBindingParent(this).setNameParticleVariant(particlesMenuNode.firstChild, document.popupNode, lastNameValue, firstNameValue, variants);
								} else {
									particlesMenuNode.disabled = true;
								}
							}
							return !hideTransforms;">
						<menuitem label="&zotero.item.creatorTransform.nameSwap;"
							oncommand="document.getBindingParent(this).swapNames(event);"/>
						<menu id="name-particles-menu" label="&zotero.item.creatorTransform.nameParticles;">
						  <menupopup>
							<menuitem label="Hello"/>
						  </menupopup>
						</menu>
					</menupopup>
					<menupopup id="mlz-language-menu"
						onpopupshowing="
						/* Abort if no languages available */
						var item = document.getBindingParent(this).item;
						if (!Zotero.CachedLanguages.getLangTags().length) {
							return false;
						}
						/* Popup Node */
						var labelNode = document.popupNode;
						if ((labelNode.localName != 'hbox' &amp;&amp; labelNode.localName != 'label') || labelNode.parentNode.classList.contains('creator-type-label')) {
							labelNode = document.popupNode.parentNode;
						}
						/* Abort if not multilingual-ize-able field */
						if (!labelNode.classList.contains('zotero-alien-clicky') &amp;&amp; !labelNode.classList.contains('creator-type-label')) {
							return false;
						}
						/* Get field type */
						var isMulti = false;
						var fieldType = 'field';
						if (labelNode.classList.contains('creator-type-label')) {
							fieldType = 'creator';
							
						}
						/* Get field name or creator index value */
						var fieldName = null;
						creatorIndex = null;
						if (fieldType == 'field') {
							fieldName = labelNode.getAttribute('fieldname');
						} else if (fieldType == 'creator') {
							var creatorIndex = parseInt(labelNode.getAttribute('fieldname').split('-')[1],10);
						}
						var rowsNode = Zotero.getAncestorByTagName(labelNode,'rows');
						if (rowsNode.classList.contains('multi')) {
							isMulti = true;
							fieldType += 'Multi';
						}
						try {
						/* Get field value */
						if (fieldType === 'field' || fieldType === 'fieldMulti') {
							var mainFieldValue = item.getField(fieldName, true);
						} else {
							var mainFieldValue = item.getCreator(creatorIndex);
						}
						/* Get row language in use */
						var rowLang = labelNode.getAttribute('zlang');
						var menu = this;
						for (var i=0,ilen=menu.childNodes.length;i&lt;ilen;i+=1) {
							menu.removeChild(menu.childNodes[0]);
						};
						/* SET LANGUAGE */
						function setLanguageMenu (menuName,langLst,menuType,functionType,fieldValue) {
							if (!langLst.length) {
								return;
							}
							var node = document.createElement('label');
							node.setAttribute('value', menuName);
							node.setAttribute('style', 'font-weight:bold;padding:0 0.5em 0 0.5em;');
							menu.appendChild(node);
							for (var i=0,ilen=langLst.length;i&lt;ilen;i+=1) {
								var nickname = langLst[i].nickname;
								var tag = langLst[i].tag;
								var itemNode = document.createElement('menuitem');
								itemNode.setAttribute('label',nickname);
								itemNode.setAttribute('value',tag);
								itemNode.setAttribute('type',menuType);
								if ('radio' === menuType) {
									itemNode.setAttribute('name','set-language');
									if (tag == rowLang) {
										itemNode.setAttribute('checked', true);
									}
									if (fieldType === 'field' || fieldType === 'fieldMulti') {
										if (!item.multi.hasLang(tag, fieldName)) {
											itemNode.setAttribute('style', 'font-style:italic;');
										}
									} else {
										if (!mainFieldValue.multi || !(mainFieldValue.multi._key[tag] || mainFieldValue.multi.main === tag)) {
											itemNode.setAttribute('style', 'font-style:italic;');
										}
									}
								}
								menu.appendChild(itemNode);
								var func = function(labelNode,tag,fieldValue) {
									return function () {
										document.getBindingParent(this)[functionType + 'LangMenuFunc'](labelNode,tag,fieldValue);
									};
								};
								var menuFunc = func(labelNode,tag,fieldValue);
								itemNode.addEventListener('click',menuFunc);
							};
						}
						if (fieldType === 'field' || fieldType === 'fieldMulti') {
							var languageList = [];
							var variantList = [];
							if (!isMulti) {
								if (mainFieldValue) {
									variantList = Zotero.CachedLanguages.getVariantList(item, fieldName, true);
									setLanguageMenu('Add Variant', variantList,null,'add',mainFieldValue);
								}
								languageList = Zotero.CachedLanguages.getLanguageList(item, fieldName, false);
								if (fieldName !== 'jurisdiction') {
									setLanguageMenu('Set Field Language', languageList,'radio','main',mainFieldValue);
								}
							} else {
								languageList = Zotero.CachedLanguages.getVariantList(item, fieldName, true);
								var multiFieldValue = item.getField(fieldName, null, null, rowLang);
								setLanguageMenu('Change Language',languageList,'radio','change',multiFieldValue);
							}
							if (!languageList.length &amp;&amp; !variantList.length) {
								return false;
							}
						}
						if (fieldType === 'creator' || fieldType === 'creatorMulti') {
							var languageList = [];
							var variantList = [];
							if (!isMulti) {
								if (mainFieldValue) {
									variantList = Zotero.CachedLanguages.getVariantList(item, creatorIndex, true);
									setLanguageMenu('Add Variant', variantList,null,'creatorAdd',mainFieldValue);
								}
								languageList = Zotero.CachedLanguages.getLanguageList(item, creatorIndex, false);
								setLanguageMenu('Set Field Language', languageList,'radio','creatorMain',mainFieldValue);
							} else {
								languageList = Zotero.CachedLanguages.getVariantList(item, creatorIndex, true);
								setLanguageMenu('Change Language',languageList,'radio','creatorChange',mainFieldValue);
							}
							if (!languageList.length &amp;&amp; !variantList.length) {
								return false;
							}
						}
						} catch(e) {
							Zotero.debug('XXX MLZ LANGUAGE MENU OOPS: '+e);
						}
						return true;">
						<menuitem label="Bogus Menu"
							oncommand="alert('Boo!');"/>
					</menupopup>
					<menupopup id="name-particles-menu" position="before_start"
							   onpopupshowing="document.getBindingParent(this).setNameParticleVariant(this, document.popupNode)">
						<menuitem label="Bogus Menu"/>
					</menupopup>
					<menupopup id="zotero-doi-menu">
						<menuitem id="zotero-doi-menu-view-online" label="&zotero.item.viewOnline;"/>
						<menuitem id="zotero-doi-menu-copy" label="&zotero.item.copyAsURL;"/>
					</menupopup>
					<zoteroguidancepanel id="zotero-author-guidance" about="authorMenu" position="after_end" x="-25"/>
				</popupset>
				<grid flex="1">
					<columns>
						<column/>
						<column flex="1"/>
					</columns>
					<rows id="dynamic-fields" flex="1">
						<row class="zotero-item-first-row">
							<label value="&zotero.items.itemType;"/>
							<menulist class="zotero-clicky" id="item-type-menu" oncommand="document.getBindingParent(this).changeTypeTo(this.value, this)" flex="1"
								onfocus="document.getBindingParent(this).ensureElementIsVisible(this)"
								onkeypress="if (event.keyCode == event.DOM_VK_TAB) { document.getBindingParent(this).itemTypeMenuTab(event); }">
								<menupopup/>
							</menulist>
						</row>
					</rows>
				</grid>
			</scrollbox>
		</content>
	</binding>
</bindings>
