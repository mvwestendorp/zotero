<?xml version="1.0"?>
<!--
    ***** BEGIN LICENSE BLOCK *****
    
    Copyright Â© 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org
    
    This file is part of Zotero.
    
    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.
    
    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.
    
    ***** END LICENSE BLOCK *****
-->

<!DOCTYPE bindings SYSTEM "chrome://zotero/locale/zotero.dtd">
<!-- <!DOCTYPE bindings SYSTEM "chrome://zotero/locale/itembox.dtd"> -->

<bindings xmlns="http://www.mozilla.org/xbl"
		  xmlns:xbl="http://www.mozilla.org/xbl"
		  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	
	<binding id="item-box">
		<resources>
			<stylesheet src="chrome://zotero/skin/bindings/itembox.css"/>
			<stylesheet src="chrome://zotero-platform/content/itembox.css"/>
		</resources>
		
		<implementation>
			<!--
				Public properties
			-->
			<field name="clickable">false</field>
			<field name="editable">false</field>
			<field name="saveOnEdit">false</field>
			<field name="showTypeMenu">false</field>
			<field name="hideEmptyFields">false</field>
			<field name="clickByRow">false</field> <!-- Click entire row rather than just field value -->
			<field name="clickByItem">false</field>
			
			<field name="clickHandler"/>
			<field name="blurHandler"/>
			<field name="eventHandlers">[]</field>
			
			<field name="_initialVisibleCreators">10</field>
			<field name="_displayAllCreators"/>
			
			<!-- Modes are predefined settings groups for particular tasks -->
			<field name="_mode">"view"</field>
			<property name="mode" onget="return this._mode;">
				<setter>
				<![CDATA[
					this.clickable = false;
					this.editable = false;
					this.saveOnEdit = false;
					this.showTypeMenu = false;
					this.hideEmptyFields = false;
					this.clickByRow = false;
					this.clickByItem = false;
					
					switch (val) {
						case 'view':
							break;
						
						case 'edit':
							this.clickable = true;
							this.editable = true;
							this.saveOnEdit = true
							this.showTypeMenu = true;
							this.clickHandler = this.showEditor;
							this.blurHandler = this.hideEditor;
							break;
						
						case 'merge':
							this.clickByItem = true;
							break;
						
						case 'mergeedit':
							this.clickable = true;
							this.editable = true;
							this.saveOnEdit = false;
							this.showTypeMenu = true;
							this.clickHandler = this.showEditor;
							this.blurHandler = this.hideEditor;
							break;
						
						case 'fieldmerge':
							this.hideEmptyFields = true;
							this._fieldAlternatives = {};
							break;
						
						default:
							throw ("Invalid mode '" + val + "' in itembox.xml");
					}
					
					this._mode = val;
					document.getAnonymousNodes(this)[0].setAttribute('mode', val);
				]]>
				</setter>
			</property>
			
			<field name="_item"/>
			<property name="item" onget="return this._item;">
				<setter>
				<![CDATA[
					if (!(val instanceof Zotero.Item)) {
						throw ("<zoteroitembox>.item must be a Zotero.Item");
					}
					
					// When changing items, reset truncation of creator list
					if (!this._item || val.id != this._item.id) {
						this._displayAllCreators = false;
					}
					if (this._item && val.id == this._item.id) {
						this._item = val;
						this.refresh(true);
					} else {
						this._item = val;
						this.refresh();
					}
				]]>
				</setter>
			</property>
			
			<!-- .ref is an alias for .item -->
			<property name="ref"
				onget="return this._item;"
				onset="this.item = val; this.refresh();">
			</property>
			
			
			<!--
				 An array of field names that should be shown
				 even if they're empty and hideEmptyFields is set
			-->
			<field name="_visibleFields">[]</field>
			<property name="visibleFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('visibleFields must be an array in <itembox>.visibleFields');
					}
					
					this._visibleFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names that should be hidden
			-->
			<field name="_hiddenFields">[]</field>
			<property name="hiddenFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('hiddenFields must be an array in <itembox>.visibleFields');
					}
					
					this._hiddenFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names that should be clickable
				 even if this.clickable is false
			-->
			<field name="_clickableFields">[]</field>
			<property name="clickableFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('clickableFields must be an array in <itembox>.clickableFields');
					}
					
					this._clickableFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names that should be editable
				 even if this.editable is false
			-->
			<field name="_editableFields">[]</field>
			<property name="editableFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('editableFields must be an array in <itembox>.editableFields');
					}
					
					this._editableFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An object of alternative values for keyed fields
				 
			-->
			<field name="_fieldAlternatives">{}</field>
			<property name="fieldAlternatives">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Object') {
						throw ('fieldAlternatives must be an Object in <itembox>.fieldAlternatives');
					}
					
					if (this.mode != 'fieldmerge') {
						throw ('fieldAlternatives is valid only in fieldmerge mode in <itembox>.fieldAlternatives');
					}
					
					this._fieldAlternatives = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names in the order they should appear
				 in the list; empty spaces can be created with null
			-->
			<field name="_fieldOrder">[]</field>
			<property name="fieldOrder">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('fieldOrder must be an array in <itembox>.fieldOrder');
					}
					
					this._fieldOrder = val;
				]]>
				</setter>
			</property>
			
			<property name="itemTypeMenu" onget="return this._id('item-type-menu')"/>
			
			<!-- Private properties -->
			<property name="_dynamicFields" onget="return this._id('dynamic-fields')"/>
			<property name="_creatorTypeMenu" onget="return this._id('creator-type-menu')"/>
			
			<field name="_selectField"/>
			<field name="_beforeRow"/>
			<field name="_addCreatorRow"/>
			<field name="_creatorCount"/>
			
			<field name="_lastTabIndex"/>
			<field name="_tabDirection"/>
			<field name="_tabIndexMinPrefields" readonly="true">1</field>
			<field name="_tabIndexMaxPrefields">0</field>
			<field name="_tabIndexMinCreators" readonly="true">100</field>
			<field name="_tabIndexMaxCreators">0</field>
			<field name="_tabIndexMinFields" readonly="true">10000</field>
			<field name="_tabIndexMaxFields">0</field>
			
			<property name="_defaultFirstName"
				onget="return '(' + Zotero.getString('pane.item.defaultFirstName') + ')'"/>
			<property name="_defaultLastName"
				onget="return '(' + Zotero.getString('pane.item.defaultLastName') + ')'"/>
			<property name="_defaultFullName"
				onget="return '(' + Zotero.getString('pane.item.defaultFullName') + ')'"/>
						
			<method name="multiTabUpdate">
				<body>
				<![CDATA[
					var nodes = document.evaluate('*//*[@ztabindex]', this._dynamicFields, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
					var creatorSeen = false;
					var fieldSeen = false;
					var count = 1;
					for (var i=0,ilen=nodes.snapshotLength;i<ilen;i++) {
						var node = nodes.snapshotItem(i);
						var fieldName = node.getAttribute('fieldname');
						var isCreator = !!fieldName.match(/^creator-/);
						if (!creatorSeen && isCreator) {
							this._tabIndexMaxPrefields = count;
							count = 100;
							creatorSeen = true;
						}
						if (creatorSeen && !fieldSeen && !isCreator) {
							this._tabIndexMaxCreators = count;
							count = 10001;
							fieldSeen = true;
						}
						var tabindex = parseInt(node.getAttribute('ztabindex'),10);
						if (tabindex > -1) {
							node.setAttribute("ztabindex", count);
						}
						count++;
					}
					this._tabIndexMaxFields = count;
				]]>
				</body>
			</method>
			
			<method name="creatorMainLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="creator"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					var [field, creatorIndex, creatorField] = fieldName.split('-');
					var creatorTypeID = creator.creatorTypeID;
					if (creator.multi.hasLang(tag, true)) {
						// If a matching value exists, swap them
						var mainLang = creator.multi.mainLang();
						var mainCreator = creator.ref;
						var variantLang = tag;
						var variantCreator = creator.multi.getCreator(tag);
						this.item.removeCreator(creatorIndex, tag);
						this.item.setCreator(creatorIndex, variantCreator, creatorTypeID, tag, true);
						this.item.setCreator(creatorIndex, mainCreator, creatorTypeID, mainLang);
						this.item.save();
					} else {
						// If no matching value exists, just adjust the UI
						var langNickname = Zotero.CachedLanguages.getNickname(tag);
						node.setAttribute('zlang',tag);
						node.setAttribute('tooltiptext',langNickname);
						var mainCreator = creator.ref;
						this.modifyCreator(creatorIndex, mainCreator, null, tag);
					}
				]]>
				</body>
			</method>
			
			<method name="creatorAddLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="fieldValue"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					var creatorIndex = parseInt(fieldName.split('-')[1],10);
					var mainCreator = this.item.getCreator(creatorIndex);
					var creatorTypeID = mainCreator.creatorTypeID;
					var langNickname = Zotero.CachedLanguages.getNickname(tag);
					var fields = {
						lastName: mainCreator.ref.lastName,
						firstName: mainCreator.ref.firstName,
						fieldMode: mainCreator.ref.fieldMode
					}
					var row = Zotero.getAncestorByTagName(node,'row');
					var rows = row.nextSibling;
					if (!rows || 'rows' !== rows.tagName || !rows.classList.contains('multi')) {
						rows = document.createElement('rows');
						rows.classList.add('multi')
						row.parentNode.insertBefore(rows,row.nextSibling)
					}
					var creator = new Zotero.Creator;
					creator.setFields(fields);
					this.addCreatorRow(creator, creatorTypeID, true, null, rows, null, tag);
				]]>
				</body>
			</method>
			
			<method name="creatorChangeLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="creator"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					var creatorIndex = parseInt(fieldName.split('-')[1],10);
					var oldTag = node.getAttribute("zlang");
					creator.multi.changeLangTag(oldTag, tag);
					if (!this.item._changedAltCreators) {
						this.item._changedAltCreators = {};
					}
					if (!this.item._changedAltCreators[creatorIndex]) {
						this.item._changedAltCreators[creatorIndex] = {};
					}
					this.item._changedAltCreators[creatorIndex][oldTag] = true;
					this.item._changedAltCreators[creatorIndex][tag] = true;
					this.item.save();
				]]>
				</body>
			</method>
			
			<method name="mainLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="fieldValue"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					// XXX Check for existing target tag among variants.
					if (this.item.multi.hasLang(tag, fieldName)) {
						// XXX If a matching variant exists, get the row and its values.
						var variantNickname = Zotero.CachedLanguages.getNickname(tag);
						var variantValue = this.item.getField(fieldName, null, null, tag);
						var row = null;
						var parentRow = Zotero.getAncestorByTagName(node, 'row');
						var rows = parentRow.nextSibling;
						if (rows.tagName === 'rows' && rows.classList.contains('multi')) {
							for (var i=0,ilen=rows.childNodes.length;i<ilen;i++) {
								var lang = rows.childNodes[i].firstChild.getAttribute('zlang');
								if (lang === tag) {
									row = rows.childNodes[i];
									break;
								}
							}
							// XXX Also get the values of main.
							var mainLang = this.item.multi.mainLang(fieldName);
							var mainValue = this.item.getField(fieldName);

							// XXX Save the variant empty to scrub it from the memory/DB object.
							// XXX This does not work, and the subsequent setField with force_top
							// XXX sets the same value on main that still lurks in the multi list.
							// XXX That should never happen, and should not be permitted.
							this.item.setField(fieldName, "", null, tag);
							this.item.save()

							// XXX Set the former variant values on main with modifyField() (not saving) and update UI
							this.item.multi.changeLangTag(mainLang, tag, fieldName);
							this._modifyField(fieldName, variantValue, null, tag, true);
							this._selectField = false;
							this.addFieldRow(999999,fieldName, variantValue, parentRow.parentNode, parentRow);
							parentRow.parentNode.removeChild(parentRow);

							// XXX Set the former main values as a variant with _modifyField() (saving this time)
							this._modifyField(fieldName, mainValue, true, mainLang)

							// XXX Insert a fresh row before the matching variant
							// XXX   with the main values, and then remove the old one.
							this._selectField = false;
							this.addFieldRow(999999,fieldName, mainValue, rows, row, mainLang);
							rows.removeChild(row);

							// XXX Update tabindexes.
							this.multiTabUpdate();
						}
					} else {
						// XXX If no matching value exists, just adjust the UI as below.
						var fieldName = node.getAttribute('fieldname');
						var langNickname = Zotero.CachedLanguages.getNickname(tag);
						node.setAttribute('zlang',tag);
						node.setAttribute('tooltiptext',langNickname);
						this._modifyField(fieldName,fieldValue,true,tag,true);
					}
				]]>
				</body>
			</method>
			
			<method name="addLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="fieldValue"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					var langNickname = Zotero.CachedLanguages.getNickname(tag);

					// Add rows sibling if necessary
					var row = Zotero.getAncestorByTagName(node,'row');
					var rows = row.nextSibling;
					if ('rows' !== rows.tagName || !rows.classList.contains('multi')) {
						rows = document.createElement('rows');
						rows.classList.add('multi')
						row.parentNode.insertBefore(rows,row.nextSibling)
					}
					this._selectField = fieldName;
					this.addFieldRow(999999,fieldName, fieldValue, rows, null, tag);
				]]>
				</body>
			</method>
			
			<method name="changeLangMenuFunc">
				<parameter name="node"/>
				<parameter name="tag"/>
				<parameter name="fieldValue"/>
				<body>
				<![CDATA[
					var fieldName = node.getAttribute('fieldname');
					var langNickname = Zotero.CachedLanguages.getNickname(tag);
					var oldTag = node.getAttribute("zlang");
					node.setAttribute('zlang',tag);
					node.setAttribute('tooltiptext',langNickname);
					node.setAttribute('value',langNickname);
					//this._modifyField(fieldName,fieldValue,true,tag);
					this.item.multi.changeLangTag(oldTag, tag, fieldName);
					this.item.save();
				]]>
				</body>
			</method>
			
			<method name="addFieldRow">
				<parameter name="tabindexValue"/>
				<parameter name="fieldName"/>
				<parameter name="fieldValue"/>
				<parameter name="parentNode"/>
				<parameter name="nextNode"/>
				<parameter name="langTag"/>
				<body>
				<![CDATA[
					var val = '';
					
					if (fieldName) {
						var fieldID = Zotero.ItemFields.getID(fieldName);
						if (fieldID && !Zotero.ItemFields.isValidForType(fieldID, this.item.itemTypeID)) {
							fieldName = null;
						}
					}
					
					if (fieldName) {
						if (this._hiddenFields.indexOf(fieldName) != -1) {
							return;
						}
						
						// createValueElement() adds the itemTypeID as an attribute
						// and converts it to a localized string for display
						if (fieldName == 'itemType') {
							val = this.item.getField('itemTypeID');
						}
						else if (fieldValue) {
							val = fieldValue;
						}
						else {
							val = this.item.getField(fieldName);
						}
						
						if (!val && this.hideEmptyFields
								&& this._visibleFields.indexOf(fieldName) == -1
								&& (this.mode != 'fieldmerge' || typeof this._fieldAlternatives[fieldName] == 'undefined')) {
							return;
						}
						
						var fieldIsClickable = this._fieldIsClickable(fieldName);
						
						// Start tabindex at 10001 after creators
						var tabindex = fieldIsClickable ? tabindexValue : 0;
						this._tabIndexMaxFields = Math.max(this._tabIndexMaxFields, tabindex);
						
						if (fieldIsClickable
								&& !Zotero.Items.isPrimaryField(fieldName)
								&& (Zotero.ItemFields.isFieldOfBase(Zotero.ItemFields.getID(fieldName), 'date')
									// TEMP - filingDate
									|| fieldName == 'filingDate')
								// TEMP - NSF
								&& fieldName != 'dateSent') {
							this.addDateRow(fieldName, this.item.getField(fieldName, true), tabindex);
							return;
						}
					}
					
					var valueElement = this.createValueElement(
						val, fieldName, tabindex, !!parentNode
					);
					
					var label = document.createElement("label");
					label.setAttribute('fieldname', fieldName);
					if (Zotero.multiFieldNames[fieldName]) {
						var fieldLang = langTag;
						if (!fieldLang) {
							fieldLang = this.item.multi.mainLang(fieldName);
					   }
						if (fieldLang) {
							label.setAttribute('zlang',fieldLang);
							var langNickname = Zotero.CachedLanguages.getNickname(fieldLang);
							label.setAttribute('tooltiptext',langNickname);
						}
						if (this.editable) {
							label.classList.add('zotero-alien-clicky');
						}
					}
					
					var prefix = '';
					// Add '(...)' before 'Abstract:' for collapsed abstracts
					if (fieldName == 'abstractNote') {
						if (val && !Zotero.Prefs.get('lastAbstractExpand')) {
							prefix = '(...) ';
						}
					}
					
					if (fieldName) {
						if (langTag) {
							var variantName = Zotero.CachedLanguages.getNickname(langTag);
							label.setAttribute("value", variantName);
						} else {
							label.setAttribute("value", prefix +
								Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, fieldName) + ":");
						}
					}
					
					// TEMP - NSF (homepage)
					if ((fieldName == 'url' || fieldName == 'homepage') && val) {
						label.setAttribute("isButton", true);
						// TODO: make getFieldValue non-private and use below instead
						label.setAttribute("onclick", "ZoteroPane_Local.loadURI(this.nextSibling.firstChild ? this.nextSibling.firstChild.nodeValue : this.nextSibling.value, event)");
						label.setAttribute("tooltiptext", Zotero.getString('locate.online.tooltip'));
					}
					else if (fieldName == 'DOI' && val && typeof val == 'string') {
						// Pull out DOI, in case there's a prefix
						var doi = Zotero.Utilities.cleanDOI(val);
						if (doi) {
							doi = "http://dx.doi.org/" + encodeURIComponent(doi);
							label.setAttribute("isButton", true);
							label.setAttribute("onclick", "ZoteroPane_Local.loadURI('" + doi + "', event)");
							label.setAttribute("tooltiptext", Zotero.getString('locate.online.tooltip'));
						}
					}
					else if (fieldName == 'abstractNote') {
						label.setAttribute("onclick",
							"if (this.nextSibling.inputField) { this.nextSibling.inputField.blur(); } "
							+ "else { document.getBindingParent(this).toggleAbstractExpand(this); }");
					}
					else {
						label.setAttribute("onclick",
							"if (this.nextSibling.inputField) { this.nextSibling.inputField.blur(); }");
						label.setAttribute("contextmenu", "mlz-language-menu");
					}
					
					var row = this.addDynamicRow(label, valueElement, null, null, parentNode, nextNode);
					if (parentNode) {
						this.multiTabUpdate();
					}
					if (fieldName && this._selectField == fieldName) {
						this.showEditor(valueElement);
						this._selectField = false;
					}
					
					// In field merge mode, add a button to switch field versions
					else if (this.mode == 'fieldmerge' && typeof this._fieldAlternatives[fieldName] != 'undefined') {
						var button = document.createElement("toolbarbutton");
						button.className = 'zotero-field-version-button';
						button.setAttribute('image', 'chrome://zotero/skin/treesource-duplicates.png');
						button.setAttribute('type', 'menu');
						
						var popup = button.appendChild(document.createElement("menupopup"));
						
						for each(var v in this._fieldAlternatives[fieldName]) {
							var menuitem = document.createElement("menuitem");
							var sv = Zotero.Utilities.ellipsize(v, 60);
							menuitem.setAttribute('label', sv);
							if (v != sv) {
								menuitem.setAttribute('tooltiptext', v);
							}
							menuitem.setAttribute('fieldName', fieldName);
							menuitem.setAttribute('originalValue', v);
							menuitem.setAttribute(
								'oncommand',
								"var binding = document.getBindingParent(this); "
								+ "var item = binding.item; "
								+ "item.setField(this.getAttribute('fieldName'), this.getAttribute('originalValue')); "
								+ "var row = Zotero.getAncestorByTagName(this, 'row'); "
								+ "binding.refresh();"
							);
							popup.appendChild(menuitem);
						}
						
						row.appendChild(button);
					}
					return row;
				]]>
				</body>
			</method>
			

			<method name="refresh">
				<parameter name="skipFields"/>
				<body>
				<![CDATA[
					if (!this.item) {
						Zotero.debug('No item to refresh', 2);
						return;
					}
					
					if (this.clickByItem) {
						var itemBox = document.getAnonymousNodes(this)[0];
						itemBox.setAttribute('onclick',
							'document.getBindingParent(this).clickHandler(this)');
					}
					
					// Item type menu
					if (this.showTypeMenu) {
						// Build item type menu if it hasn't been built yet
						if (this.itemTypeMenu.itemCount == 0) {
							this.buildItemTypeMenu();
						}
						else {
							this.updateItemTypeMenuSelection();
						}
						
						this.itemTypeMenu.parentNode.hidden = false;
					}
					else {
						this.itemTypeMenu.parentNode.hidden = true;
					}
					
					
					//
					// Clear and rebuild metadata fields
					//
					if (skipFields) {
						var nodes = document.evaluate('*[local-name()="rows" and contains(@class,"creator")]', this._dynamicFields, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
						for (var i=nodes.snapshotLength-1;i>-1;i--) {
							var node = nodes.snapshotItem(i);
							node.parentNode.removeChild(node);
						}
					} else {
						while (this._dynamicFields.childNodes.length > 1) {
							this._dynamicFields.removeChild(this._dynamicFields.lastChild);
						}
					}
					
					var fieldNames = [];
					
					// Manual field order
					if (this._fieldOrder.length) {
						for each(var field in this._fieldOrder) {
							fieldNames.push(field);
						}
					}
					// Get field order from database
					else {
						if (!this.showTypeMenu) {
							fieldNames.push("itemType");
						}
						
						var fields = Zotero.ItemFields.getItemTypeFields(this.item.getField("itemTypeID"));
						
						for (var i=0; i<fields.length; i++) {
							fieldNames.push(Zotero.ItemFields.getName(fields[i]));
						}
						
						fieldNames.push("dateAdded", "dateModified");
					}
					
					if (!skipFields) {
						var tabCount = this._tabIndexMinFields;
						for (var i=0; i<fieldNames.length; i++) {
							var fieldName = fieldNames[i];
							var virtualTabCount = i>0 ? tabCount : 1;
							var mainRow = this.addFieldRow(virtualTabCount,fieldName);
							tabCount += 1;
							var multiData = this.item.multi.data(fieldName);
							if (multiData.length) {
								// XXX Add a rows sibling
								var multiRows = document.createElement('rows');
								multiRows.classList.add('multi');
								var nextRow = mainRow.nextSibling;
								mainRow.parentNode.insertBefore(multiRows, nextRow);
								for (var j=0,jlen=multiData.length;j<jlen;j++) {
									var variantData = multiData[j];
									this.addFieldRow(tabCount, fieldName, variantData.value, multiRows, null, variantData.languageTag);
									tabCount += 1;
								}
							}
						}
					}

					//
					// Creators
					//
					
					// Creator type menu
					if (this.editable) {
						while (this._creatorTypeMenu.hasChildNodes()) {
							this._creatorTypeMenu.removeChild(this._creatorTypeMenu.firstChild);
						}
						
						var creatorTypes = Zotero.CreatorTypes.getTypesForItemType(this.item.itemTypeID);
						var localized = {};
						for (var i=0; i<creatorTypes.length; i++) {
							localized[creatorTypes[i]['name']]
								= Zotero.getString('creatorTypes.' + creatorTypes[i]['name']);
						}
						
						for (var i in localized) {
							var menuitem = document.createElement("menuitem");
							menuitem.setAttribute("label", localized[i]);
							menuitem.setAttribute("typeid", Zotero.CreatorTypes.getID(i));
							this._creatorTypeMenu.appendChild(menuitem);
						}
						
						var moveSep = document.createElement("menuseparator");
						var moveUp = document.createElement("menuitem");
						var moveDown = document.createElement("menuitem");
						moveSep.id = "zotero-creator-move-sep";
						moveUp.id = "zotero-creator-move-up";
						moveDown.id = "zotero-creator-move-down";
						moveUp.className = "zotero-creator-move";
						moveDown.className = "zotero-creator-move";
						moveUp.setAttribute("label", Zotero.getString('pane.item.creator.moveUp'));
						moveDown.setAttribute("label", Zotero.getString('pane.item.creator.moveDown'));
						this._creatorTypeMenu.appendChild(moveSep);
						this._creatorTypeMenu.appendChild(moveUp);
						this._creatorTypeMenu.appendChild(moveDown);
					}

					// Creator rows
					
					// Place, in order of preference, after title, after type,
					// or at beginning
					var titleFieldID = Zotero.ItemFields.getFieldIDFromTypeAndBase(this.item.itemTypeID, 'title');
					var field = this._dynamicFields.getElementsByAttribute('fieldname', Zotero.ItemFields.getName(titleFieldID)).item(0);
					if (!field) {
						var field = this._dynamicFields.getElementsByAttribute('fieldname', 'itemType').item(0);
					}
					if (field) {
						if ('rows' === field.parentNode.nextSibling.tagName) {
							this._beforeRow = field.parentNode.nextSibling.nextSibling;
						}
						else {
							this._beforeRow = field.parentNode.nextSibling;
						}
					}
					else {
						this._beforeRow = this._dynamicFields.firstChild;
					}
					
					this._creatorCount = 0;
					var num = this.item.numCreators();
					if (num > 0) {
						// Limit number of creators display
						var max = Math.min(num, this._initialVisibleCreators);
						// If fewer than five more, just display
						if (num < max + 5 || this._displayAllCreators) {
							max = num;
						}
						for (var i = 0; i < max; i++) {
							var creator = this.item.getCreator(i);
							var row = this.addCreatorRow(creator.ref,
								creator.creatorTypeID,
								null,
								null,
								null,
								null,
								creator.multi.mainLang());
							
							// Display "+" button on all but last row
							if (i == max - 2) {
								this.disableCreatorAddButtons();
							}
							
							var langs = creator.multi.langs();
							if (langs.length) {
								var mainRow = row.firstChild;
								var rows = mainRow.nextSibling;
								if (!rows || rows.tagName !== 'rows' || !rows.classList.contains('multi')) {
									rows = document.createElement('rows');
									rows.classList.add('multi');
									mainRow.parentNode.appendChild(rows);
								}
								for (var j=0,jlen=langs.length;j<jlen;j++) {
									var multicreator = creator.multi.getCreator(langs[j])
									this.addCreatorRow(multicreator,
										creator.creatorTypeID,
										null,
										null,
										rows,
										null,
										langs[j]);
								}
							}

						}
						
						// Additional creators not displayed
						if (num > max) {
							this.addMoreCreatorsRow(num - max);
							
							this.disableCreatorAddButtons();
						}
						else {
							// If we didn't start with creators truncated,
							// don't truncate for as long as we're viewing
							// this item, so that added creators aren't
							// immediately hidden
							this._displayAllCreators = true;
							
							if (this._addCreatorRow) {
								this.addCreatorRow(false, this.item.getCreator(max-1).creatorTypeID, true); 
								this._addCreatorRow = false;
								this.disableCreatorAddButtons();
							}
						}
					}
					else if (this.editable && Zotero.CreatorTypes.itemTypeHasCreators(this.item.itemTypeID)) {
						// Add default row
						this.addCreatorRow(false, false, true, true);
						this.disableCreatorAddButtons();
					}
					
					this.multiTabUpdate();

					// Move to next or previous field if (shift-)tab was pressed
					if (this._lastTabIndex && this._tabDirection)
					{
						this._focusNextField(this._dynamicFields, this._lastTabIndex, this._tabDirection == -1);
					}
				]]>
				</body>
			</method>
			
			
			<method name="buildItemTypeMenu">
				<body>
				<![CDATA[
					if (!this.item) {
						return;
					}
					
					this.itemTypeMenu.removeAllItems();
					
					var t = Zotero.ItemTypes.getTypes();
							
					// Sort by localized name
					var itemTypes = [];
					for (var i=0; i<t.length; i++) {
						itemTypes.push({
							id: t[i].id,
							name: t[i].name,
							localized: Zotero.ItemTypes.getLocalizedString(t[i].id)
						});
					}
					var collation = Zotero.getLocaleCollation();
					itemTypes.sort(function(a, b) {
						return collation.compareString(1, a.localized, b.localized);
					});
					
					for (var i=0; i<itemTypes.length; i++) {
						var name = itemTypes[i].name;
						if (name != 'attachment' && name != 'note') {
							this.itemTypeMenu.appendItem(itemTypes[i].localized, itemTypes[i].id);
						}
					}
					
					this.updateItemTypeMenuSelection();
				]]>
				</body>
			</method>
			
			
			<method name="updateItemTypeMenuSelection">
				<body>
				<![CDATA[
					var listitems = this.itemTypeMenu.firstChild.childNodes;
					for (var i=0, len=listitems.length; i < len; i++) {
						if (listitems[i].getAttribute('value') == this.item.itemTypeID) {
							this.itemTypeMenu.selectedIndex = i;
						}
					}
				]]>
				</body>
			</method>
			
			
			<method name="addDynamicRow">
				<parameter name="label"/>
				<parameter name="value"/>
				<parameter name="addBeforeElement"/>
				<parameter name="isCreatorElement"/>
				<parameter name="parentElement"/>
				<parameter name="nextElement"/>
				<body>
				<![CDATA[
					// Add click event to row
					if (this._rowIsClickable(value.getAttribute('fieldname'))) {
						row.className = 'zotero-clicky';
						row.addEventListener('click', function (event) {
							document.getBindingParent(this).clickHandler(this);
						}, false);
					}
					
					if (!parentElement && value.getAttribute('fieldname') == 'jurisdiction') {
						var innerValue = value;
						innerValue.setAttribute("tooltiptext", value.getAttribute("label"));
						value = document.createElement("hbox");
						value.appendChild(innerValue);
						var jurisdictionDefault = document.createElement("checkbox");
						jurisdictionDefault.setAttribute("label","default");
						jurisdictionDefault.setAttribute("id","jurisdiction-default");
						jurisdictionDefault.setAttribute("oncommand","document.getBindingParent(this).jurisdictionDefaultCommand(this);");
						if (this.item.getField("jurisdiction") === Zotero.Prefs.get("import.jurisdictionDefault")) {
							jurisdictionDefault.setAttribute("checked",true);
						}
						value.appendChild(jurisdictionDefault);
						var row = document.createElement("row");
						row.appendChild(label);
						row.appendChild(value);
					} else if (!parentElement && value.getAttribute('fieldname') == 'court') {
						//value.setAttribute("tooltiptext", value.getAttribute("label"));
						var row = document.createElement("row");
						row.appendChild(label);
						var boxedvalue = document.createElement("hbox");
						boxedvalue.appendChild(value);
						row.appendChild(boxedvalue);
					} else if (isCreatorElement && !parentElement) {
						var row = document.createElement('rows');
						row.classList.add('creator');
						var subrow = document.createElement('row');
						row.appendChild(subrow);
						subrow.appendChild(label);
						subrow.appendChild(value);
					} else {
						var row = document.createElement("row");
						row.appendChild(label);
						row.appendChild(value);
					}


					if (!parentElement) {
						parentElement = this._dynamicFields;
					}
					var elementToPlaceBefore = null;
					if (nextElement) {
						elementToPlaceBefore = nextElement;
					} else if (addBeforeElement) {
						elementToPlaceBefore = this._beforeRow;
					}
					if (elementToPlaceBefore) {
						parentElement.insertBefore(row, elementToPlaceBefore);
					}
					else {
						parentElement.appendChild(row);
					}
					
					return row;
				]]>
				</body>
			</method>
			
			<method name="jurisdictionDefaultCommand">
			  <parameter name="node"/>
			  <body>
				<![CDATA[
					var checked = node.getAttribute("checked");
					if (checked) {
						var jurisdictionNode = document.getElementById("jurisdiction-menu");
						var jurisdiction = jurisdictionNode.getAttribute("value");
						Zotero.Prefs.set("import.jurisdictionDefault",jurisdiction);
					} else {
						Zotero.Prefs.set("import.jurisdictionDefault","");
					}
				]]>
			  </body>
			</method>

			
			<method name="addCreatorRow">
				<parameter name="creator"/>
				<parameter name="creatorTypeID"/>
				<parameter name="unsaved"/>
				<parameter name="defaultRow"/>
				<parameter name="parentNode"/>
				<parameter name="nextNode"/>
				<parameter name="langTag"/>
				<body>
				<![CDATA[
					// getCreatorFields(), switchCreatorMode() and handleCreatorAutoCompleteSelect()
					// may need need to be adjusted if this DOM structure changes
					
					if (parentNode) {
						this._creatorCount--;
					}
					
					if (!creator) {
						creator = {
							firstName: '',
							lastName: '',
							fieldMode: Zotero.Prefs.get('lastCreatorFieldMode')
						};
					}
					
					if (creator.fieldMode == 1) {
						var firstName = '';
						var lastName = creator.lastName ? creator.lastName : this._defaultFullName;
					}
					else {
						var firstName = creator.firstName ? creator.firstName : this._defaultFirstName;
						var lastName = creator.lastName ? creator.lastName : this._defaultLastName;
					}
					
					// Use the first entry in the drop-down for the default type if none specified
					var typeID = creatorTypeID ?
						creatorTypeID : this._creatorTypeMenu.childNodes[0].getAttribute('typeid');
					
					var typeBox = document.createElement("hbox");
					typeBox.setAttribute("typeid", typeID);
					if (!parentNode) {
						typeBox.setAttribute("popup", "creator-type-menu");
					}
					typeBox.setAttribute("fieldname", 'creator-' + this._creatorCount + '-typeID');
					if (langTag) {
						typeBox.setAttribute("zlang", langTag);
						typeBox.setAttribute("tooltiptext", Zotero.CachedLanguages.getNickname(langTag));
					}
					if (this.editable) {
						typeBox.setAttribute("contextmenu", "mlz-language-menu");
						if (!parentNode) {
							typeBox.className = 'creator-type-label zotero-clicky';
							var img = document.createElement('image');
							typeBox.appendChild(img);
						} else {
							typeBox.classList.add('creator-type-label');
							typeBox.classList.add('zotero-alien-clicky');
						}
					}
					else {
						typeBox.className = 'creator-type-label';
					}
					
					var label = document.createElement("label");
					if (!parentNode) {
						label.setAttribute('value',
							Zotero.getString('creatorTypes.'+Zotero.CreatorTypes.getName(typeID)) + ":")
					} else {
						label.setAttribute('value', Zotero.CachedLanguages.getNickname(langTag));
					}
					typeBox.appendChild(label);
					var hbox = document.createElement("hbox");
					hbox.className = 'creator-type-value';
					
					// Name
					var firstlast = document.createElement("hbox");
					firstlast.className = 'creator-name-box';
					firstlast.setAttribute("flex","1");
					var tabindex = this._tabIndexMinCreators + (this._creatorCount * 2);
					var fieldName = 'creator-' + this._creatorCount + '-lastName';
					var lastNameLabel = firstlast.appendChild(
						this.createValueElement(
							lastName,
							fieldName,
							tabindex
						)
					);
					
					// Comma
					var comma = document.createElement('label');
					comma.setAttribute('value', ',');
					comma.className = 'comma';
					firstlast.appendChild(comma);
					
					var fieldName = 'creator-' + this._creatorCount + '-firstName';
					firstlast.appendChild(
						this.createValueElement(
							firstName,
							fieldName,
							tabindex + 1
						)
					);
					if (creator.fieldMode) {
						firstlast.lastChild.setAttribute('hidden', true);
					}
					
					if (this.editable) {
						firstlast.setAttribute('contextmenu', 'zotero-creator-transform-menu');
					}
					
					this._tabIndexMaxCreators = Math.max(this._tabIndexMaxCreators, tabindex);
					
					hbox.appendChild(firstlast);
					
					// Single/double field toggle
					var toggleButton = document.createElement('label');
					toggleButton.setAttribute('fieldname',
						'creator-' + this._creatorCount + '-fieldMode');
					toggleButton.className = 'zotero-field-toggle zotero-clicky';
					hbox.appendChild(toggleButton);
					
					// Minus (-) button
					var removeButton = document.createElement('label');
					removeButton.setAttribute("value","-");
					removeButton.setAttribute("class","zotero-clicky zotero-clicky-minus");
					// If default first row, don't let user remove it
					if (defaultRow) {
						this.disableButton(removeButton);
					}
					else {
						removeButton.setAttribute("onclick",
							"document.getBindingParent(this).removeCreator("
							+ this._creatorCount
							+ ", this.parentNode.parentNode)");
					}
					hbox.appendChild(removeButton);
					
					// Plus (+) button
					var addButton = document.createElement('label');
					addButton.setAttribute("value","+");
					addButton.setAttribute("class", "zotero-clicky zotero-clicky-plus");
					// If row isn't saved, don't let user add more
					if (unsaved) {
						this.disableButton(addButton);
					}
					else {
						this._enablePlusButton(addButton, typeID, creator.fieldMode);
					}
					hbox.appendChild(addButton);
					
					if (parentNode) {
						toggleButton.setAttribute('hidden', true);
						//removeButton.setAttribute('hidden', true);
						addButton.setAttribute('hidden', true);
					} else {
						this._creatorCount++;
					}
					
					if (!this.editable) {
						toggleButton.hidden = true;
						removeButton.hidden = true;
						addButton.hidden = true;
					}

					var placementFlag = true;
					if (parentNode) {
						placementFlag = false;
					}
					var row = this.addDynamicRow(typeBox, hbox, placementFlag, true, parentNode, nextNode);
					
					if (unsaved) {
						this.multiTabUpdate();
					}

					// Set single/double field toggle mode
					if (creator.fieldMode) {
						this.switchCreatorMode(hbox.parentNode, 1, true);
					}
					else {
						this.switchCreatorMode(hbox.parentNode, 0, true);
					}

					// Focus new rows
					if (unsaved && !defaultRow){
						lastNameLabel.click();
					}

					if (parentNode) {
						this._creatorCount++;
					}
					
					return row;
				]]>
				</body>
			</method>
			
			
			<method name="addMoreCreatorsRow">
				<parameter name="num"/>
				<body>
				<![CDATA[
					var box = document.createElement('box');
					
					var label = document.createElement('label');
					label.id = 'more-creators-label';
					label.setAttribute('value', Zotero.getString('general.numMore', num));
					label.setAttribute('onclick',
						"var binding = document.getBindingParent(this); "
						+ "binding._displayAllCreators = true; "
						+ "binding.refresh()"
					);
					
					this.addDynamicRow(box, label, true, true);
				]]>
				</body>
			</method>
			
			<method name="addDateRow">
				<parameter name="field"/>
				<parameter name="value"/>
				<parameter name="tabindex"/>
				<body>
				<![CDATA[
					var label = document.createElement("label");
					label.setAttribute("value", Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, field) + ':');
					label.setAttribute("fieldname", field);
					label.setAttribute("onclick", "this.nextSibling.firstChild.blur()");
					
					var elem = this.createValueElement(
						Zotero.Date.multipartToStr(value),
						field,
						tabindex
					);
					elem.setAttribute('flex', 1);
					
					// y-m-d status indicator
					var ymd = document.createElement('label');
					ymd.id = 'zotero-date-field-status';
					ymd.setAttribute(
						'value',
						Zotero.Date.strToDate(Zotero.Date.multipartToStr(value))
							.order.split('').join(' ')
					);
					
					var hbox = document.createElement('hbox');
					hbox.setAttribute('flex', 1);
					hbox.className = "date-box";
					hbox.appendChild(elem);
					hbox.appendChild(ymd);
					
					this.addDynamicRow(label, hbox);
				]]>
				</body>
			</method>
			
			
			<method name="switchCreatorModeOnAll">
				<parameter name="row"/>
				<parameter name="fieldMode"/>
				<parameter name="initial"/>
				<parameter name="updatePref"/>
				<body>
				<![CDATA[
					var rows = row.nextSibling;
					this.saveOnEdit = false;
					if (rows && rows.tagName === 'rows' && rows.classList.contains('multi')) {
						for (var i=0,ilen=rows.childNodes.length;i<ilen;i++) {
							this.switchCreatorMode(rows.childNodes[i], fieldMode, false, false, true);
						}
					}
					this.saveOnEdit = true;
					this.switchCreatorMode(row, fieldMode, false, true, false);
				]]>
				</body>
			</method>
			
			

			<method name="switchCreatorMode">
				<parameter name="row"/>
				<parameter name="fieldMode"/>
				<parameter name="initial"/>
				<parameter name="updatePref"/>
				<parameter name="isMulti"/>
				<body>
				<![CDATA[
					// Change if button position changes
					// row->hbox->label->label->toolbarbutton
					var button = row.lastChild.lastChild.previousSibling.previousSibling;
					var hbox = button.previousSibling;
					var lastName = hbox.firstChild;
					var comma = hbox.firstChild.nextSibling;
					var firstName = hbox.lastChild;
					var langTag = row.firstChild.getAttribute("zlang");
					
					// Switch to single-field mode
					if (fieldMode == 1) {
						button.style.backgroundImage = 'url("chrome://zotero/skin/textfield-dual.png")';
						button.setAttribute('tooltiptext', Zotero.getString('pane.item.switchFieldMode.two'));
						lastName.setAttribute('fieldMode', '1');
						button.setAttribute('onclick', "document.getBindingParent(this).switchCreatorModeOnAll(Zotero.getAncestorByTagName(this, 'row'), 0, false, true)");
						lastName.setAttribute('flex', '1');
						delete lastName.style.width;
						delete lastName.style.maxWidth;
						
						// Remove firstname field from tabindex
						var tab = parseInt(firstName.getAttribute('ztabindex'));
						firstName.setAttribute('ztabindex', -1);
						if (this._tabIndexMaxCreators == tab) {
							this._tabIndexMaxCreators--;
						}
						
						// Hide first name field and prepend to last name field
						firstName.setAttribute('hidden', true);
						comma.setAttribute('hidden', true);
						
						if (!initial) {
							var first = this._getFieldValue(firstName);
							if (first && first != this._defaultFirstName) {
								var last = this._getFieldValue(lastName);
								this._setFieldValue(lastName, first + ' ' + last);
							}
						}
						
						if (this._getFieldValue(lastName) == this._defaultLastName) {
							this._setFieldValue(lastName, this._defaultFullName);
						}
					}
					// Switch to two-field mode
					else {
						button.style.backgroundImage = 'url("chrome://zotero/skin/textfield-single.png")';
						button.setAttribute('tooltiptext', Zotero.getString('pane.item.switchFieldMode.one'));
						lastName.setAttribute('fieldMode', '0');
						button.setAttribute('onclick', "document.getBindingParent(this).switchCreatorModeOnAll(Zotero.getAncestorByTagName(this, 'row'), 1, false, true)");
						lastName.setAttribute('flex', '0');
						
						// appropriately truncate lastName
						
						// get item box width
						var computedStyle = window.getComputedStyle(this, null);
						var boxWidth = computedStyle.getPropertyValue('width');
						// get field label width
						var computedStyle = window.getComputedStyle(row.firstChild, null);
						var leftHboxWidth = computedStyle.getPropertyValue('width');
						// get last name width
						computedStyle = window.getComputedStyle(lastName, null);
						var lastNameWidth = computedStyle.getPropertyValue('width');
						if(boxWidth.substr(-2) === 'px'
								&& leftHboxWidth.substr(-2) === 'px'
								&& lastNameWidth.substr(-2) === "px") {
							// compute a maximum width
							boxWidth = parseInt(boxWidth);
							leftHboxWidth = parseInt(leftHboxWidth);
							lastNameWidth = parseInt(lastNameWidth);
							var maxWidth = boxWidth-leftHboxWidth-140;
							if(lastNameWidth > maxWidth) {
								lastName.style.width = maxWidth+"px";
								lastName.style.maxWidth = maxWidth+"px";
							} else {
								delete lastName.style.width;
								delete lastName.style.maxWidth;
							}
						}
						
						// Add firstname field to tabindex
						var tab = parseInt(lastName.getAttribute('ztabindex'));
						firstName.setAttribute('ztabindex', tab + 1);
						if (this._tabIndexMaxCreators == tab)
						{
							this._tabIndexMaxCreators++;
						}
						
						if (!initial) {
							// Move all but last word to first name field and show it
							var last = this._getFieldValue(lastName);
							if (last && last != this._defaultFullName) {
								var lastNameRE = /(.*?)[ ]*([^ ]+[ ]*)$/;
								var parts = lastNameRE.exec(last);
								if (parts[2] && parts[2] != last)
								{
									this._setFieldValue(lastName, parts[2]);
									this._setFieldValue(firstName, parts[1]);
								}
							}
						}
						
						if (!this._getFieldValue(firstName)) {
							this._setFieldValue(firstName, this._defaultFirstName);
						}
						
						if (this._getFieldValue(lastName) == this._defaultFullName) {
							this._setFieldValue(lastName, this._defaultLastName);
						}
						
						firstName.setAttribute('hidden', false);
						comma.setAttribute('hidden', false);
					}
					
					// Save the last-used field mode
					if (updatePref) {
						Zotero.debug("Switching lastCreatorFieldMode to " + fieldMode);
						Zotero.Prefs.set('lastCreatorFieldMode', fieldMode);
					}
					
					if (!initial)
					{
						var index = button.getAttribute('fieldname').split('-')[1];
						var fields = this.getCreatorFields(row);
						fields.fieldMode = fieldMode;
						this.modifyCreator(index, fields, null, langTag, isMulti);
					}
				]]>
				</body>
			</method>
			
			
			<method name="scrollToTop">
				<body>
				<![CDATA[
					// DEBUG: Valid nsIScrollBoxObject but methods return errors
					return;
					
					var sbo = document.getAnonymousNodes(this)[0].boxObject;
					sbo.QueryInterface(Components.interfaces.nsIScrollBoxObject);
					sbo.scrollTo(0,0);
				]]>
				</body>
			</method>
			
			
			<method name="ensureElementIsVisible">
				<parameter name="elem"/>
				<body>
				<![CDATA[
					var sbo = document.getAnonymousNodes(this)[0].boxObject;
					sbo.QueryInterface(Components.interfaces.nsIScrollBoxObject);
					sbo.ensureElementIsVisible(elem);
				]]>
				</body>
			</method>
			
			
			<method name="changeTypeTo">
				<parameter name="itemTypeID"/>
				<parameter name="menu"/>
				<body>
				<![CDATA[
					if (itemTypeID == this.item.itemTypeID) {
						return true;
					}
					
					var fieldsToDelete = this.item.getFieldsNotInType(itemTypeID, true);
					
					// Special cases handled below
					var bookTypeID = Zotero.ItemTypes.getID('book');
					var bookSectionTypeID = Zotero.ItemTypes.getID('bookSection');
					
					// Add warning for shortTitle when moving from book to bookSection
					// when title will be transferred
					if (this.item.itemTypeID == bookTypeID && itemTypeID == bookSectionTypeID) {
						var titleFieldID = Zotero.ItemFields.getID('title');
						var shortTitleFieldID = Zotero.ItemFields.getID('shortTitle');
						if (this.item.getField(titleFieldID) && this.item.getField(shortTitleFieldID)) {
							if (!fieldsToDelete) {
								fieldsToDelete = [];
							}
							fieldsToDelete.push(shortTitleFieldID);
						}
					}
					
					// Generate list of localized field names for display in pop-up
					if (fieldsToDelete) {
						// Ignore warning for bookTitle when going from bookSection to book
						// if there's not also a title, since the book title is transferred
						// to title automatically in Zotero.Item.setType()
						if (this.item.itemTypeID == bookSectionTypeID && itemTypeID == bookTypeID) {
							var titleFieldID = Zotero.ItemFields.getID('title');
							var bookTitleFieldID = Zotero.ItemFields.getID('bookTitle');
							var shortTitleFieldID = Zotero.ItemFields.getID('shortTitle');
							if (this.item.getField(bookTitleFieldID) && !this.item.getField(titleFieldID)) {
								var index = fieldsToDelete.indexOf(bookTitleFieldID);
								fieldsToDelete.splice(index, 1);
								// But warn for short title, which will be removed
								if (this.item.getField(shortTitleFieldID)) {
									fieldsToDelete.push(shortTitleFieldID);
								}
							}
						}
						
						var fieldNames = "";
						for (var i=0; i<fieldsToDelete.length; i++) {
							fieldNames += "\n - " +
								Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, fieldsToDelete[i]);
						}
						
						var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
							.getService(Components.interfaces.nsIPromptService);
					}
					
					if (!fieldsToDelete || fieldsToDelete.length == 0 ||
							promptService.confirm(null,
								Zotero.getString('pane.item.changeType.title'),
								Zotero.getString('pane.item.changeType.text') + "\n" + fieldNames)) {
						this.item.setType(itemTypeID);
						
						// Force jurisdiction value if required
						this.forceJurisdiction(itemTypeID);
						
						if (this.saveOnEdit) {
							this.item.save();
						}
						else {
							this.refresh();
						}
						
						if (this.eventHandlers['itemtypechange'] && this.eventHandlers['itemtypechange'].length) {
							var self = this;
							this.eventHandlers['itemtypechange'].forEach(function (f) f.bind(self)());
						}
						
						return true;
					}
					
					// Revert the menu (which changes before the pop-up)
					if (menu) {
						menu.value = this.item.itemTypeID;
					}
					
					return false;
				]]>
				</body>
			</method>
			
			
			<method name="forceJurisdiction">
				<parameter name="itemTypeID"/>
				<body>
				<![CDATA[
						// XXXX Factor this out to a function. It will be used in two places.
						var jurisdictionID = Zotero.ItemFields.getID('jurisdiction');
						var fields = Zotero.ItemFields.getItemTypeFields(itemTypeID);
						if (fields.indexOf(jurisdictionID) > -1) {
							var itemType = Zotero.ItemTypes.getName(itemTypeID);
							if (["report","newspaperArticle","journalArticle"].indexOf(itemType) === -1) {
								if (!this.item.getField(jurisdictionID)) {
									var jurisdictionDefault = Zotero.Prefs.get("import.jurisdictionDefault");
									var jurisdictionFallback = Zotero.Prefs.get("import.jurisdictionFallback");
									if (jurisdictionDefault) {
										this.item.setField(jurisdictionID,jurisdictionDefault);
									} else if (jurisdictionFallback) {
										this.item.setField(jurisdictionID,jurisdictionFallback);
									} else {
										this.item.setField(jurisdictionID,"us");
									}
								}
							}
						}
				]]>
				</body>
			</method>

			
			<method name="toggleAbstractExpand">
				<parameter name="label"/>
				<body>
				<![CDATA[
					var cur = Zotero.Prefs.get('lastAbstractExpand');
					Zotero.Prefs.set('lastAbstractExpand', !cur);
					
					var ab = label.nextSibling;
					var valueText = this.item.getField('abstractNote');
					var tabindex = ab.getAttribute('ztabindex');
					var elem = this.createValueElement(
						valueText,
						'abstractNote',
						tabindex
					);
					ab.parentNode.replaceChild(elem, ab);
					
					var text = Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, 'abstractNote') + ':';
					// Add '(...)' before "Abstract:" for collapsed abstracts
					if (valueText && cur) {
						text = '(...) ' + text;
					}
					label.setAttribute('value', text);
				]]>
				</body>
			</method>
			
			
			<method name="disableButton">
				<parameter name="button"/>
				<body>
				<![CDATA[
					button.setAttribute('disabled', true);
					button.setAttribute('onclick', false); 
				]]>
				</body>
			</method>
			
			
			<method name="_enablePlusButton">
				<parameter name="button"/>
				<parameter name="creatorTypeID"/>
				<parameter name="fieldMode"/>
				<body>
				<![CDATA[
					button.setAttribute('disabled', false);
					button.setAttribute("onclick",
						"var parent = document.getBindingParent(this); "
						+ "parent.disableButton(this); "
						+ "var creator = new Zotero.Creator; "
						+ "creator.fieldMode = " + (fieldMode ? fieldMode : 0) + "; "
						+ "parent.addCreatorRow("
							+ "creator, "
							+ (creatorTypeID ? creatorTypeID : 'false') + ", true"
						+ ");"
					);
				]]>
				</body>
			</method>
			
			
			<method name="disableCreatorAddButtons">
				<body>
				<![CDATA[
					// Disable the "+" button on all creator rows
					var elems = this._dynamicFields.getElementsByAttribute('value', '+');
					for (var i = 0, len = elems.length; i < len; i++) {
						this.disableButton(elems[i]);
					}
				]]>
				</body>
			</method>
			
			
			<method name="showJurisdictionEditor">
				<parameter name="node"/>
				<body>
				<![CDATA[
					var tabindex = node.getAttribute("ztabindex");
					var value = node.getAttribute('label');
					var textbox = document.createElement('textbox');
					textbox.setAttribute("ztabindex", tabindex);
					textbox.setAttribute('value',value);
					textbox.setAttribute("oldComment",node.getAttribute("value"));
					textbox.setAttribute("oldValue",node.getAttribute("label"));
					textbox.setAttribute("flex","1");
					textbox.setAttribute('emptytext','Enter a jurisdiction');

					textbox.setAttribute('type','autocomplete');
					textbox.setAttribute('autocompletesearch','zotero');
					let params = {
						fieldName: "jurisdictions"
					}
					textbox.setAttribute('ontextentered',
						'document.getBindingParent(this).handleJurisdictionAutoCompleteSelect(this)');
					textbox.setAttribute(
						'autocompletesearchparam', JSON.stringify(params)
					);
					textbox.setAttribute('completeselectedindex', true);

					node.parentNode.replaceChild(textbox, node)
					
					textbox.setAttribute('onkeypress', "return document.getBindingParent(this).handleKeyPress(event)");

					textbox.addEventListener('blur', function (event) {
					  document.getBindingParent(this).hideJurisdictionEditor(this);
					}, false);
					textbox.select();
					this._tabDirection = false;
					this._lastTabIndex = tabindex;
				]]>
				</body>
			</method>


			<method name="showCourtEditor">
				<parameter name="node"/>
				<body>
				<![CDATA[
					var tabindex = node.getAttribute("ztabindex");
					var jurisdictionID = document.getElementById("jurisdiction-menu").getAttribute("value");
					var countryID = jurisdictionID.split(":")[0];
					var value = node.getAttribute('label');
					var textbox = document.createElement('textbox');
					textbox.setAttribute("ztabindex", tabindex);
					textbox.setAttribute('value',value);
					textbox.setAttribute("oldComment",node.getAttribute("value"));
					textbox.setAttribute("oldValue",node.getAttribute("label"));
					textbox.setAttribute("flex","1");
					textbox.setAttribute('emptytext','Select a court or enter its name');

					textbox.setAttribute('type','autocomplete');
					textbox.setAttribute('autocompletesearch','zotero');
					let params = {
						fieldName: 'courts',
						jurisdictionID: jurisdictionID,
						countryID: countryID
					}
					textbox.setAttribute('ontextentered',
						'document.getBindingParent(this).handleCourtAutoCompleteSelect(this)');
					textbox.setAttribute(
						'autocompletesearchparam', JSON.stringify(params)
					);
					textbox.setAttribute('completeselectedindex', true);
					textbox.setAttribute('enablehistory', true);

					node.parentNode.replaceChild(textbox, node)

					textbox.setAttribute('onkeypress', "return document.getBindingParent(this).handleKeyPress(event)");

					textbox.addEventListener('blur', function (event) {
						document.getBindingParent(this).hideCourtEditor(this);
					}, false);
					textbox.select();
					this._tabDirection = false;
					this._lastTabIndex = tabindex;
				]]>
				</body>
			</method>


			<method name="handleJurisdictionKeypress">
				<parameter name="event"/>
				<body>
				<![CDATA[
				   //alert(textbox.mController);
				   var target = event.target;
				   var focused = document.commandDispatcher.focusedElement;
				   switch (event.keyCode) {
					 case event.DOM_VK_ESCAPE:
					 case event.DOM_VK_RETURN:
					   event.preventDefault();
					   event.target.blur();
					   break;
					 case event.DOM_VK_TAB:
					   this._tabDirection = event.shiftKey ? -1 : 1;
					   this._focusNextField(this._dynamicFields, this._lastTabIndex, this._tabDirection == -1);
					   event.preventDefault();
					   return true;
				   }
				   return false;
				]]>
				</body>
			</method>

			<method name="hideJurisdictionEditor">
				<parameter name="node"/>
				<parameter name="result"/>
				<body>
				<![CDATA[
					if (!result) {
				  		var itemType = Zotero.ItemTypes.getName(this.item.itemTypeID);
				  		if (["report","newspaperArticle","journalArticle"].indexOf(itemType) == -1) {
				  			result = {val:node.getAttribute("oldValue"),comment:node.getAttribute("oldComment")};
				  		} else {
				  			result = {val:"",comment:""};
				  		}
					}
					var tabindex = node.getAttribute("ztabindex");
					
					var valueElement = document.createElement("menulist");
					valueElement.setAttribute("id","jurisdiction-menu");
					valueElement.setAttribute("ztabindex", tabindex);
					valueElement.setAttribute("flex","1");
					valueElement.setAttribute("class", "zotero-clicky");
					valueElement.setAttribute("onclick","document.getBindingParent(this).showJurisdictionEditor(this);");
					valueElement.setAttribute("value",result.comment);
					valueElement.setAttribute("label",result.val);
					valueElement.setAttribute("tooltiptext",result.val);
					node.parentNode.replaceChild(valueElement,node);
					this.setJurisdictionKey(result.comment, valueElement);
					
					var xpath = '*[local-name()="row"]/'
						+ '*[local-name()="label" and @fieldname="court"]/'
						+ 'following-sibling::*[local-name()="hbox"]/'
						+ '*[local-name()="menulist"]';
					var courtNodes = document.evaluate(xpath, this._dynamicFields, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
					if (courtNodes.snapshotLength) {
						var courtNode = courtNodes.snapshotItem(0);
						var courtIdOrName = courtNode.getAttribute('value');
						var oldJurisdictionID = node.getAttribute('oldComment');
						var newJurisdictionID = result.comment;
						var newCourtID = Zotero.Utilities.remapCourtName(oldJurisdictionID, newJurisdictionID, courtIdOrName);
						courtNode.setAttribute('value', newCourtID);
						var newCourtName = Zotero.Utilities.getCourtName(newJurisdictionID, newCourtID);
						// How did we do
						if (newCourtName) {
							courtNode.setAttribute('value', newCourtName);
							courtNode.removeAttribute('style');
						} else {
							courtNode.setAttribute('value', newCourtID);
							courtNode.setAttribute('style', 'background:yellow;');
						}
					}

					if (this._tabDirection) {
						var focusBox = this._dynamicFields;
						this._focusNextField(focusBox, this._lastTabIndex, this._tabDirection == -1);
					}
				]]>
				</body>
			</method>


			<method name="hideCourtEditor">
				<parameter name="node"/>
				<parameter name="result"/>
				<body>
				<![CDATA[
					var valueElement = document.createElement("menulist");
					if (!result) {
						var newValue = node.value;
						var jurisdictionID = this.item.getField('jurisdiction');
						var newComment = Zotero.Utilities.getCourtID(jurisdictionID, newValue, true);
				  		result = {val:newValue,comment:newComment};
						if (newValue == newComment) {
							valueElement.setAttribute("style","background:yellow;");
						}
					}
					
					var tabindex = node.getAttribute("ztabindex");
					
					valueElement.setAttribute("id","court-menu");
					valueElement.setAttribute("ztabindex", tabindex);
					valueElement.setAttribute("flex","1");
					valueElement.setAttribute("class", "zotero-clicky");
					valueElement.setAttribute("onclick","document.getBindingParent(this).showCourtEditor(this);");
					valueElement.setAttribute("value",result.comment);
					valueElement.setAttribute("label",result.val);
					valueElement.setAttribute("tooltiptext",result.val);
					node.parentNode.replaceChild(valueElement,node);
					this.item.setField("court",result.comment);
					this.item.save();
					
					if (this._tabDirection) {
						var focusBox = this._dynamicFields;
						this._focusNextField(focusBox, this._lastTabIndex, this._tabDirection == -1);
					}
				]]>
				</body>
			</method>


			<method name="handleJurisdictionAutoCompleteSelect">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
					var result = false;
					var controller = textbox.controller;
					if (!controller.matchCount) return;
					
					for (var i=0; i<controller.matchCount; i++) {
						if (controller.getValueAt(i) == textbox.value) {
							result = {val:controller.getValueAt(i),comment:controller.getCommentAt(i)};
							break;
						}
					}
					textbox.mController.input = null;
					this.hideJurisdictionEditor(textbox, result);
				]]>
				</body>
			</method>

			<method name="handleCourtAutoCompleteSelect">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
					var result = false;
					var controller = textbox.controller;
					if (!controller.matchCount) return;
					
					for (var i=0; i<controller.matchCount; i++) {
						if (controller.getValueAt(i) == textbox.value) {
							result = {val:controller.getValueAt(i),comment:controller.getCommentAt(i)};
							break;
						}
					}
					textbox.mController.input = null;
					this.hideCourtEditor(textbox, result);
				]]>
				</body>
			</method>

			<method name="createValueElement">
				<parameter name="valueText"/>
				<parameter name="fieldName"/>
				<parameter name="tabindex"/>
				<parameter name="isMulti"/>
				<body>
				<![CDATA[
					valueText = valueText + '';
					
					if (fieldName) {
						var fieldID = Zotero.ItemFields.getID(fieldName);
					}
					
					// If an abstract, check last expand state
					var abstractAsVbox = fieldName == 'abstractNote' && Zotero.Prefs.get('lastAbstractExpand');
					
					// Use a vbox for multiline fields (but Abstract only if it's expanded)
					var useVbox = (fieldName != 'abstractNote' || abstractAsVbox)
						&& Zotero.ItemFields.isMultiline(fieldName);
					
					if (!isMulti && fieldName === 'jurisdiction') {
						var valueElement = document.createElement("menulist");
						valueElement.setAttribute("id","jurisdiction-menu");
						// XXXX Set default here if req.
						this.forceJurisdiction(this.item.itemTypeID);
						var value = this.item.getField("jurisdiction",true);
						if (value) {
							var label = Zotero.Utilities.getJurisdictionName(value);
							if (!label) {
								label = value;
								valueElement.setAttribute("style","background:yellow;");
							} else {
								label = label.split("|");
								if (label.length > 2) {
									label = label.slice(1).join("|");
								} else {
									label = label.join("|");
								}
							}
							valueElement.setAttribute("label", label);
							valueElement.setAttribute("value", value);
						}
					}
					else if (!isMulti && fieldName === 'court') {
						var valueElement = document.createElement("menulist");
						valueElement.setAttribute("id","court-menu");
						var jurisdictionValue = this.item.getField("jurisdiction",true);
						var value = this.item.getField("court",true);
						if (jurisdictionValue && value) {
						
							var label = Zotero.Utilities.getCourtName(jurisdictionValue, value);

							if (!label) {
								label = value;
								// Double-check for validity - may contain a correct court name string
								// on upgrade or immediately after data import
								if (!Zotero.Utilities.getCourtID(jurisdictionValue, value)) {
									valueElement.setAttribute("style","background:yellow;");
								}
							}
							valueElement.setAttribute("label", label);
							valueElement.setAttribute("value", value);
						}
					}
					else if (useVbox) {
						var valueElement = document.createElement("vbox");
					}
					else {
						var valueElement = document.createElement("label");
					}
					
					valueElement.setAttribute('fieldname', fieldName);
					valueElement.setAttribute('flex', 1);
					
					if (this._fieldIsClickable(fieldName)) {
						valueElement.setAttribute('ztabindex', tabindex);
						if (!(!isMulti && (fieldName === 'jurisdiction' || fieldName === 'court'))) {
						valueElement.addEventListener('click', function (event) {
							/* Skip right-click on Windows */
							if (event.button) {
								return;
							}
							document.getBindingParent(this).clickHandler(this);
						}, false);
						}
						valueElement.className = 'zotero-clicky';
					}
					
					switch (fieldName) {
						case 'jurisdiction':
							if (!isMulti) {
								valueElement.setAttribute("onclick","document.getBindingParent(this).showJurisdictionEditor(this);");
								return valueElement;
							}
							break;
							
						case 'court':
							if (!isMulti) {
								valueElement.setAttribute("onclick","document.getBindingParent(this).showCourtEditor(this);");
								return valueElement;
							}
							break;

						case 'itemType':
							valueElement.setAttribute('itemTypeID', valueText);
							valueText = Zotero.ItemTypes.getLocalizedString(valueText);
							break;
						
						// Convert dates from UTC
						case 'dateAdded':
						case 'dateModified':
						case 'accessDate':
						
						// TEMP - NSF
						case 'dateSent':
						case 'dateDue':
						case 'accepted':
							if (valueText) {
								var date = Zotero.Date.sqlToDate(valueText, true);
								if (date) {
									// If no time, interpret as local, not UTC
									if (Zotero.Date.isSQLDate(valueText)) {
										date = Zotero.Date.sqlToDate(valueText);
										valueText = date.toLocaleDateString();
									}
									else {
										valueText = date.toLocaleString();
									}
								}
								else {
									valueText = '';
								}
							}
							break;
					}
					
					if (fieldID) {
						// Display the SQL date as a tooltip for date fields
						// TEMP - filingDate
						if (Zotero.ItemFields.isFieldOfBase(fieldID, 'date') || fieldName == 'filingDate') {
							valueElement.setAttribute('tooltiptext',
								Zotero.Date.multipartToSQL(this.item.getField(fieldName, true)));
						}
						
						// Display a context menu for certain fields
						if (this.editable && (fieldName == 'seriesTitle' || fieldName == 'shortTitle' ||
								Zotero.ItemFields.isFieldOfBase(fieldID, 'title') ||
								Zotero.ItemFields.isFieldOfBase(fieldID, 'publicationTitle'))) {
							valueElement.setAttribute('contextmenu', 'zotero-field-transform-menu');
						}
					}
					
					
					if (fieldName && fieldName.indexOf('firstName') != -1) {
						valueElement.setAttribute('flex', '1');
					}
					
					var firstSpace = valueText.indexOf(" ");
					
					// To support newlines in Abstract and Extra fields, use multiple
					// <description> elements inside a vbox
					if (useVbox) {
						var lines = valueText.split("\n");
						for (var i = 0; i < lines.length; i++) {
							var descriptionNode = document.createElement("description");
							// Add non-breaking space to empty lines to prevent them from collapsing.
							// (Just using CSS min-height results in overflow in some cases.)
							if (lines[i] === "") {
								lines[i] = "\u00a0";
							}
							var linetext = document.createTextNode(lines[i]);
							descriptionNode.appendChild(linetext);
							valueElement.appendChild(descriptionNode);
						}
					}
					// 29 == arbitrary length at which to chop uninterrupted text
					else if ((firstSpace == -1 && valueText.length > 29 ) || firstSpace > 29
						|| (fieldName &&
							(fieldName.substr(0, 7) == 'creator') || fieldName == 'abstractNote')) {
						if (fieldName == 'abstractNote') {
							valueText = valueText.replace(/[\t\n]/g, ' ');
						}
						valueElement.setAttribute('crop', 'end');
						valueElement.setAttribute('value',valueText);
					}
					else {
						// Wrap to multiple lines
						valueElement.appendChild(document.createTextNode(valueText));
					}
					
					return valueElement;
				]]>
				</body>
			</method>
			
			
			<method name="removeCreator">
				<parameter name="index"/>
				<parameter name="labelToDelete"/>
				<body>
				<![CDATA[
					// If unsaved row, just remove element
					if (!this.item.hasCreatorAt(index)) {
						labelToDelete.parentNode.removeChild(labelToDelete);
						
						// Enable the "+" button on the previous row
						var elems = this._dynamicFields.getElementsByAttribute('value', '+');
						var button = elems[elems.length-1];
						var creatorFields = this.getCreatorFields(Zotero.getAncestorByTagName(button, 'row'));
						this._enablePlusButton(button, creatorFields.creatorTypeID, creatorFields.fieldMode);
						
						this._creatorCount--;
						return;
					}
					// Block delete if there are multilingual variants
					isMulti = labelToDelete.parentNode.classList.contains('multi');
					if (isMulti) {
						var langTag = labelToDelete.firstChild.getAttribute("zlang");
						this.item.removeCreator(index, langTag);
					} else {
						if (!(labelToDelete.nextSibling && labelToDelete.nextSibling.tagName === 'rows')) {
							this.item.removeCreator(index);
						}
					}
					this.item.save();
				]]>
				</body>
			</method>
			
			
			<method name="showEditor">
				<parameter name="elem"/>
				<body>
				<![CDATA[
					// Blur any active fields
					if (this._dynamicFields) {
						this._dynamicFields.focus();
					}
					
					Zotero.debug('XXX Showing editor');
					
					var fieldName = elem.getAttribute('fieldname');
					var tabindex = elem.getAttribute('ztabindex');
					
					var row = Zotero.getAncestorByTagName(elem, 'row');
					var label = row.firstChild;
					var langTag = label.getAttribute('zlang');
					var isMulti = false;
					if (row.parentNode.classList.contains('multi')) {
						isMulti = true;
					}

					var [field, creatorIndex, creatorField] = fieldName.split('-');
					if (field == 'creator') {
						var fields = this.getCreatorFields(row);
						var c = this.item.getCreator(creatorIndex);
						if (isMulti) {
							var c = c.multi.getCreator(langTag);
							var value = c ? c[creatorField] : '';
							var value = !value && fields[creatorField] ? fields[creatorField] : value;
						} else {
							var value = c ? c.ref[creatorField] : '';
						}
						var itemID = this.item.id;
					}
					else {
						var value = this.item.getField(fieldName, null, null, langTag);
						// This ordinary showEditor() function will run on jurisdiction
						// and court only when adding or editing a multilingual variant
						// Use human-readable form for jurisdictions and court names
						if (fieldName === 'jurisdiction') {
							value = Zotero.Utilities.getJurisdictionName(value, true);
						} else if (fieldName === 'court') {
							var jurisdictionID = this.item.getField('jurisdiction', true);
							value = Zotero.Utilities.getCourtName(jurisdictionID, value, true);
						}
						
						var itemID = this.item.id;
						
						// Access date needs to be converted from UTC
						if (value != '') {
							switch (fieldName) {
								case 'accessDate':
								
								// TEMP - NSF
								case 'dateSent':
								case 'dateDue':
								case 'accepted':
									// If no time, interpret as local, not UTC
									if (Zotero.Date.isSQLDate(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
									}
									else {
										var localDate = Zotero.Date.sqlToDate(value, true);
									}
									var value = Zotero.Date.dateToSQL(localDate);
									
									// Don't show time in editor
									value = value.replace(' 00:00:00', '');
									break;
							}
						}
					}
					
					var t = document.createElement("textbox");
					t.setAttribute('value', value);
					t.setAttribute('fieldname', fieldName);
					t.setAttribute('ztabindex', tabindex);
					t.setAttribute('flex', '1');
					
					if (creatorField=='lastName') {
						t.setAttribute('fieldMode', elem.getAttribute('fieldMode'));
						t.setAttribute('newlines','pasteintact');
					}
					
					if (Zotero.ItemFields.isMultiline(fieldName) || Zotero.ItemFields.isLong(fieldName)) {
						t.setAttribute('multiline', true);
						t.setAttribute('rows', 8);
					}
					else {
						// Add auto-complete for certain fields
						if (Zotero.ItemFields.isAutocompleteField(fieldName)
								|| fieldName == 'creator') {
							t.setAttribute('type', 'autocomplete');
							t.setAttribute('autocompletesearch', 'zotero');
							
							let params = {
								fieldName: fieldName,
								libraryID: this.item.libraryID
							};
							if (field == 'creator') {
								params.fieldMode = parseInt(elem.getAttribute('fieldMode'));
								
								// Include itemID and creatorTypeID so the autocomplete can
								// avoid showing results for creators already set on the item
								let row = Zotero.getAncestorByTagName(elem, 'row');
								let creatorTypeID = parseInt(
									row.getElementsByClassName('creator-type-label')[0]
									.getAttribute('typeid')
								);
								if (itemID) {
									params.itemID = itemID;
									params.creatorTypeID = creatorTypeID;
								}
								
								t.setAttribute('ontextentered',
									'document.getBindingParent(this).handleCreatorAutoCompleteSelect(this)');
							};
							t.setAttribute(
								'autocompletesearchparam', JSON.stringify(params)
							);
							t.setAttribute('completeselectedindex', true);
						}
					}
					var box = elem.parentNode;
					box.replaceChild(t, elem);
					
					// Prevent error when clicking between a changed field
					// and another -- there's probably a better way
					if (!t.select) {
						return;
					}
					
					t.select();
					
					// Leave text field open when window loses focus
					var ignoreBlur = function () {
						this.ignoreBlur = true;
					}.bind(this);
					var unignoreBlur = function () {
						this.ignoreBlur = false;
					}.bind(this);
					addEventListener("deactivate", ignoreBlur);
					addEventListener("activate", unignoreBlur);
					
					t.addEventListener('blur', function () {
						var self = document.getBindingParent(this);
						if (self.ignoreBlur) return;
						
						removeEventListener("deactivate", ignoreBlur);
						removeEventListener("activate", unignoreBlur);
						self.blurHandler(this);
					});
					t.setAttribute('onkeypress', "return document.getBindingParent(this).handleKeyPress(event)");
					
					this._tabDirection = false;
					this._lastTabIndex = tabindex;
					
					return t;
				]]>
				</body>
			</method>
			
			
			<!--
			 Save a multiple-field selection for the creator autocomplete
			 (e.g. "Shakespeare, William")
			-->
			<method name="handleCreatorAutoCompleteSelect">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
					var comment = false;
					var controller = textbox.controller;
					if (!controller.matchCount) return;
					
					for (var i=0; i<controller.matchCount; i++)
					{
						if (controller.getValueAt(i) == textbox.value)
						{
							comment = controller.getCommentAt(i);
							break;
						}
					}
					
					var [creatorID, numFields] = comment.split('-');
					
					// If result uses two fields, save both
					if (numFields==2)
					{
						// Manually clear autocomplete controller's reference to
						// textbox to prevent error next time around
						textbox.mController.input = null;
						
						var [field, creatorIndex, creatorField] =
							textbox.getAttribute('fieldname').split('-');
						
						// Stay focused
						this._lastTabIndex = parseInt(textbox.getAttribute('ztabindex')) - 1;
						this._tabDirection = 1;
						
						var creator = Zotero.Creators.get(creatorID);
						
						var otherField = creatorField == 'lastName' ? 'firstName' : 'lastName';
						
						// Update this textbox
						textbox.setAttribute('value', creator[creatorField]);
						textbox.value = creator[creatorField];
						
						// Update the other label
						if (otherField=='firstName'){
							var label = textbox.nextSibling.nextSibling;
						}
						else if (otherField=='lastName'){
							var label = textbox.previousSibling.previousSibling;
						}
						
						//this._setFieldValue(label, creator[otherField]);
						if (label.firstChild){
							label.firstChild.nodeValue = creator[otherField];
						}
						else {
							label.value = creator[otherField];
						}
						
						var row = Zotero.getAncestorByTagName(textbox, 'row');
						
						var fields = this.getCreatorFields(row);
						fields[creatorField] = creator[creatorField];
						fields[otherField] = creator[otherField];
						this.modifyCreator(creatorIndex, fields);
					}
					
					// Otherwise let the autocomplete popup handle matters
				]]>
				</body>
			</method>
			
			
			<method name="handleKeyPress">
				<parameter name="event"/>
				<body>
				<![CDATA[
					var target = event.target;
					var focused = document.commandDispatcher.focusedElement;
					
					switch (event.keyCode)
					{
						case event.DOM_VK_RETURN:
							var fieldname = target.getAttribute('fieldname');
							// Use shift-enter as the save action for the larger fields
							if (Zotero.ItemFields.isMultiline(fieldname) && !event.shiftKey) {
								break;
							}
							
							
							// Prevent blur on containing textbox
							// DEBUG: what happens if this isn't present?
							event.preventDefault();
							
							// Shift-enter adds new creator row
							if (fieldname.indexOf('creator-') == 0 && event.shiftKey) {
								// Value hasn't changed
								if (target.getAttribute('value') == target.value) {
									Zotero.debug("Value hasn't changed");
									// If + button is disabled, just focus next creator row
									if (Zotero.getAncestorByTagName(target, 'row').lastChild.lastChild.disabled) {
										this._focusNextField(this._dynamicFields, this._lastTabIndex, false);
									}
									else {
										var creatorFields = this.getCreatorFields(Zotero.getAncestorByTagName(target, 'row'));
										this.addCreatorRow(false, creatorFields.creatorTypeID, true);
									}
								}
								// Value has changed
								else {
									this._tabDirection = 1;
									this._addCreatorRow = true;
									focused.blur();
								}
								return false;
							}
							focused.blur();
							
							// Return focus to items pane
							var tree = document.getElementById('zotero-items-tree');
							if (tree) {
								tree.focus();
							}
							
							return false;
							
						case event.DOM_VK_ESCAPE:
							// Reset field to original value
							target.value = target.getAttribute('value');
							
							focused.blur();
							
							// Return focus to items pane
							var tree = document.getElementById('zotero-items-tree');
							if (tree) {
								tree.focus();
							}
							
							return false;
							
						case event.DOM_VK_TAB:
							this._tabDirection = event.shiftKey ? -1 : 1;
							// Blur the old manually -- not sure why this is necessary,
							// but it prevents an immediate blur() on the next tag
							focused.blur();
							return false;
					}
					
					return true;
				]]>
				</body>
			</method>
			
			
			<method name="itemTypeMenuTab">
				<parameter name="event"/>
				<body>
				<![CDATA[
					if (!event.shiftKey) {
						this.focusFirstField();
						event.preventDefault();
					}
					// Shift-tab
					else {
						this._tabDirection = false;
					}
				]]>
				</body>
			</method>
			

			<method name="jurisdictionMenuTab">
				<parameter name="event"/>
				<body>
				<![CDATA[
					var elem = event.target;
					var ztabindex = elem.getAttribute("ztabindex");
					var tabindex = parseInt(elem.getAttribute("ztabindex"),10);
					if (!event.shiftKey) {
						tabindex += 1;
					} else {
						// Shift-tab
						tabindex += -1;
					}
					var nextelem = this._dynamicFields.getElementsByAttribute("ztabindex",tabindex)[0];
					nextelem.click();
					event.preventDefault();
 				]]>
 				</body>
			</method>
			
			
			<method name="hideEditor">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
				try {
					Zotero.debug('Hiding editor');
					/*
					var textbox = Zotero.getAncestorByTagName(t, 'textbox');
					if (!textbox){
						Zotero.debug('Textbox not found in hideEditor');
						return;
					}
					*/
					
					// TODO: get rid of this?
					var saveChanges = this.saveOnEdit;
					
					// Prevent autocomplete breakage in Firefox 3
					if (textbox.mController) {
						textbox.mController.input = null;
					}
					
					var fieldName = textbox.getAttribute('fieldname');
					var tabindex = textbox.getAttribute('ztabindex');
					
					//var value = t.value;
					var value = textbox.value;
					
					var elem;
					var [field, creatorIndex, creatorField] = fieldName.split('-');
					
					var row = Zotero.getAncestorByTagName(textbox, 'row');
					var isMulti = false;
					var rows = Zotero.getAncestorByTagName(row, 'rows');
					if (rows.classList.contains('multi')) {
					   isMulti = true;
					}
					var fieldLang = row.firstChild.getAttribute('zlang');
					
					if (field !== 'creator' && (!value || !value.trim())) {
						if (isMulti) {
							// XXX Could probably be a little smoother here.
							this.item.setField(fieldName,null,null,fieldLang)
							rows.removeChild(row);
							if (!rows.childNodes.length) {
								rows.parentNode.removeChild(rows);
							}
							this.multiTabUpdate();
							this.item.save();
							return;
						} else if (this.item.multi.langs(field).length) {
							value = this.item.getField(field);
						}
					}

					// Creator fields
					if (field == 'creator') {
						var otherFields = this.getCreatorFields(row);
						otherFields[creatorField] = value;
						var lastName = otherFields.lastName.trim();
						
						if (isMulti) {
							var firstName = otherFields.firstName ? otherFields.firstName.trim() : '';
							if (!lastName && !firstName) {
								var creator = this.item.getCreator(creatorIndex);
								creator.multi.removeCreator(fieldLang);
								if (!this.item._changedAltCreators) {
									this.item._changedAltCreators = {};
								}
								if (!this.item._changedAltCreators[creatorIndex]) {
									this.item._changedAltCreators[creatorIndex] = {};
								}
								this.item._changedAltCreators[creatorIndex][fieldLang] = true;
								// XXX Is this really needed???
								this.item.save();
								this.refresh(true);
								return;
							}
						}

						//Handle \n\r and \n delimited entries
						var rawNameArray = lastName.split(/\r\n?|\n/);
						if (rawNameArray.length > 1) {
							//Save tab direction and add creator flags since they are reset in the 
							//process of adding multiple authors
							var tabDirectionBuffer = this._tabDirection;
							var addCreatorRowBuffer = this._addCreatorRow;
							var tabIndexBuffer = this._lastTabIndex;
							this._tabDirection = false;
							this._addCreatorRow = false;
							
							//Filter out bad names
							var nameArray = [tempName for each(tempName in rawNameArray) if(tempName)];
							
							//If not adding names at the end of the creator list, make new creator 
							//entries and then shift down existing creators.
							var initNumCreators = this.item.numCreators();
							var creatorsToShift = initNumCreators - creatorIndex;
							if (creatorsToShift > 0) { 
								//Add extra creators
								for (var i=0;i<nameArray.length;i++) {
									this.modifyCreator(i+initNumCreators,otherFields);
								}
								
								//Shift existing creators
								for (var i=initNumCreators-1; i>=creatorIndex; i--) {
									var shiftedCreator = this.item.getCreator(i);
									this.item.setCreator(nameArray.length+i,shiftedCreator.ref,shiftedCreator.creatorTypeID);
								}
							}
							
							//Add the creators in lastNameArray one at a time
							for each(var tempName in nameArray) {
								// Check for tab to determine creator name format
								otherFields.fieldMode = (tempName.indexOf('\t') == -1) ? 1 : 0;
								if (otherFields.fieldMode == 0) {
									otherFields.lastName=tempName.split('\t')[0];
									otherFields.firstName=tempName.split('\t')[1];
								} 
								else {
									otherFields.lastName=tempName;
									otherFields.firstName='';
								}
								this.modifyCreator(creatorIndex,otherFields);
								creatorIndex++;
							}
							this._tabDirection = tabDirectionBuffer;
							this._addCreatorRow = (creatorsToShift==0) ? addCreatorRowBuffer : false;
							if (this._tabDirection == 1) {
								this._lastTabIndex = parseInt(tabIndexBuffer,10) + 2*(nameArray.length-1);
								if (otherFields.fieldMode == 0) {
									this._lastTabIndex++;
								}
							}
						}
						else {
							this.modifyCreator(creatorIndex, otherFields, null, fieldLang, isMulti);
						}
	
						var c = this.item.getCreator(creatorIndex);
						if (isMulti) {
							var c = c.multi.getCreator(fieldLang);
							var val = c ? c[creatorField] : '';
						} else {
							var val = c ? c.ref[creatorField] : null;
						}

						if (!val) {
							// Reset to '(first)'/'(last)'/'(name)'
							if (creatorField == 'lastName') {
							val = otherFields.fieldMode
								? this._defaultFullName : this._defaultLastName;
							}
							else if (creatorField == 'firstName') {
							val = this._defaultFirstName;
							}
						}
						
						elem = this.createValueElement(
							val,
							fieldName,
							tabindex
						);
					}
					
					// Fields
					else {
						// Access date needs to be parsed and converted to UTC
						if (value != '') {
							switch (fieldName) {
								case 'accessDate':
									// If just date, don't convert to UTC
									if (Zotero.Date.isSQLDate(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
										value = Zotero.Date.dateToSQL(localDate).replace(' 00:00:00', '');
									}
									else if (Zotero.Date.isSQLDateTime(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
										value = Zotero.Date.dateToSQL(localDate, true);
									}
									else {
										var d = Zotero.Date.strToDate(value);
										value = null;
										if (d.year && d.month != undefined && d.day) {
											d = new Date(d.year, d.month, d.day);
											value = Zotero.Date.dateToSQL(d).replace(' 00:00:00', '');
										}
									}
									break;
								
								// TEMP - NSF
								case 'dateSent':
								case 'dateDue':
								case 'accepted':
									if (Zotero.Date.isSQLDate(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
										value = Zotero.Date.dateToSQL(localDate).replace(' 00:00:00', '');
									}
									else {
										var d = Zotero.Date.strToDate(value);
										value = null;
										if (d.year && d.month != undefined && d.day) {
											d = new Date(d.year, d.month, d.day);
											value = Zotero.Date.dateToSQL(d).replace(' 00:00:00', '');
										}
									}
									break;
								
								default:
									// TODO: generalize to all date rows/fields
									if (Zotero.ItemFields.isFieldOfBase(fieldName, 'date')) {
										// Parse 'yesterday'/'today'/'tomorrow' and convert to dates,
										// since it doesn't make sense for those to be actual metadata values
										var lc = value.toLowerCase();
										if (lc == 'yesterday' || lc == Zotero.getString('date.yesterday')) {
											value = Zotero.Date.dateToSQL(new Date(new Date().getTime() - 86400000)).substr(0, 10);
										}
										else if (lc == 'today' || lc == Zotero.getString('date.today')) {
											value = Zotero.Date.dateToSQL(new Date()).substr(0, 10);
										}
										else if (lc == 'tomorrow' || lc == Zotero.getString('date.tomorrow')) {
											value = Zotero.Date.dateToSQL(new Date(new Date().getTime() + 86400000)).substr(0, 10);
										}
									}
							}
						}

						this._modifyField(fieldName, value, this.saveOnEdit, fieldLang, !isMulti);
						
						elem = this.createValueElement(
							this.item.getField(fieldName, null, null, fieldLang),
							fieldName,
							tabindex,
							isMulti
						);
					}
					
					var box = textbox.parentNode;
					box.replaceChild(elem,textbox);
					
					if(field === 'creator') {
						// Reset creator mode settings here so that flex attribute gets reset
						this.switchCreatorMode(row, (otherFields.fieldMode ? 1 : 0), true);
						
						if(Zotero.ItemTypes.getName(this.item.itemTypeID) === "bookSection") {
							var creatorTypeLabels = document.getAnonymousNodes(this)[0].getElementsByClassName("creator-type-label");
							document.getElementById("zotero-author-guidance").show(creatorTypeLabels[creatorTypeLabels.length-1]);
						}
					}
					
					if (this._tabDirection) {
						var focusBox = this._dynamicFields;
						this._focusNextField(focusBox, this._lastTabIndex, this._tabDirection == -1);
					}
				}
				// Thrown errors don't seem to show up within XBL without explicit logging
				catch (e) {
					Zotero.debug(e);
					Components.utils.reportError(e);
					throw (e);
				}
				]]>
				</body>
			</method>
			
			
			<method name="_rowIsClickable">
				<parameter name="fieldName"/>
				<body>
				<![CDATA[
				 	return this.clickByRow &&
						(this.clickable ||
							this._clickableFields.indexOf(fieldName) != -1);
				]]>
				</body>
			</method>
			
			
			<method name="_fieldIsClickable">
				<parameter name="fieldName"/>
				<body>
				<![CDATA[
					return !this.clickByRow &&
						((this.clickable && !Zotero.Items.isPrimaryField(fieldName))
							|| this._clickableFields.indexOf(fieldName) != -1);
				]]>
				</body>
			</method>
			
			<method name="_modifyField">
				<parameter name="field"/>
				<parameter name="value"/>
				<parameter name="save"/>
				<parameter name="lang"/>
				<parameter name="force_top"/>
				<body>
				<![CDATA[
					this.item.setField(field,value,null,lang,force_top);
					if (save) {
						this.item.save();
					}
				]]>
				</body>
			</method>
			
			
			<method name="_getFieldValue">
				<parameter name="label"/>
				<body>
				<![CDATA[
					return label.firstChild
						? label.firstChild.nodeValue : label.value;
				]]>
				</body>
			</method>
			
			
			<method name="_setFieldValue">
				<parameter name="label"/>
				<parameter name="value"/>
				<body>
				<![CDATA[
					if (label.firstChild) {
						label.firstChild.nodeValue = value;
					}
					else {
						label.value = value;
					}
				]]>
				</body>
			</method>
			
			
			<!-- TODO: work with textboxes too -->
			<method name="textTransform">
				<parameter name="label"/>
				<parameter name="mode"/>
				<body>
				<![CDATA[
					var val = this._getFieldValue(label);
					switch (mode) {
						case 'title':
							var newVal = Zotero.Utilities.capitalizeTitle(val.toLowerCase(), true);
							break;
						case 'sentence':
							// capitalize the first letter, including after beginning punctuation
							// capitalize after ?, ! and remove space(s) before those as well as colon analogous to capitalizeTitle function
							// also deal with initial punctuation here - open quotes and Spanish beginning punctuation marks
							newVal = val.toLowerCase().replace(/\s*:/, ":");
							newVal = newVal.replace(/(([\?!]\s*|^)([\'\"Â¡Â¿âââÂ«\s]+)?[^\s])/g, function (x) {
								return x.replace(/\s+/m, " ").toUpperCase();});
							break;
						default:
							throw ("Invalid transform mode '" + mode + "' in zoteroitembox.textTransform()");
					}
					this._setFieldValue(label, newVal);
					this._modifyField(label.getAttribute('fieldname'), newVal, this.saveOnEdit);

				]]>
				</body>
			</method>
			
			
			<method name="getCreatorFields">
				<parameter name="row"/>
				<body>
				<![CDATA[
					var typeID = row.getElementsByClassName('creator-type-label')[0].getAttribute('typeid');
					var label1 = row.getElementsByClassName('creator-name-box')[0].firstChild;
					var label2 = label1.parentNode.lastChild;
					
					var fields = {
						lastName: label1.firstChild ? label1.firstChild.nodeValue
							: label1.value,
						firstName: label2.firstChild ? label2.firstChild.nodeValue
							: label2.value,
						fieldMode: label1.getAttribute('fieldMode')
							? parseInt(label1.getAttribute('fieldMode')) : 0,
						creatorTypeID: parseInt(typeID),
					};
					
					// Ignore '(first)'
					if (fields.fieldMode == 1 || fields.firstName == this._defaultFirstName) {
						fields.firstName = '';
					}
					// Ignore '(last)' or '(name)'
					if (fields.lastName == this._defaultFullName
							|| fields.lastName == this._defaultLastName) {
						fields.lastName = '';
					}
					
					return fields;
				]]>
				</body>
			</method>
			
			
			<method name="modifyCreator">
				<parameter name="index"/>
				<parameter name="fields"/>
				<parameter name="changeGlobally"/>
				<parameter name="langTag"/>
				<parameter name="isMulti"/>
				<body>
				<![CDATA[
				try {
					var libraryID = this.item.libraryID;
					var firstName = fields.firstName;
					var lastName = fields.lastName;
					//var shortName = fields.shortName;
					var fieldMode = fields.fieldMode;
					var creatorTypeID = fields.creatorTypeID;
					
					var oldCreator = this.item.getCreator(index);
					if (langTag && isMulti) {
						var oldCreatorMain = oldCreator;
						oldCreator = oldCreatorMain.multi.getCreator(langTag, true);
					}
					// Don't save empty creators
					if (!firstName && !lastName){
						if (!oldCreator) {
							return
						}
						if (langTag && isMulti) {
							this.item.removeCreator(index, langTag);
						} else {
							// XXX Use xpath to check if multi creators exist, block if they do.
							var xpath = '*[local-name()="rows" and contains(@class,"creator")][' + (index+1) + ']/*[local-name()="rows" and contains(@class,"multi")]';
							var nodes = document.evaluate(xpath, this._dynamicFields, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
							if (!nodes.snapshotLength) {
								this.item.removeCreator(index);
							}
						}
						this.item.save();
						return;
					}
					
					if (isMulti) {
						if (langTag) {
							oldCreator = {
								ref: oldCreator,
								creatorTypeID:oldCreatorMain.creatorTypeID
							};
						} else {
							throw "isMulti set without langTag value";
						}
					}

					Zotero.DB.beginTransaction();
					
					var newCreator = new Zotero.Creator;
					newCreator.libraryID = libraryID;
					newCreator.setFields(fields);
					
					var newLinkedCreators = [];
					var creatorDataID = Zotero.Creators.getDataID(fields);
					if (creatorDataID) {
						newLinkedCreators = Zotero.Creators.getCreatorsWithData(creatorDataID, libraryID);
					}
					if (!oldCreator.ref) {
						oldCreator = null;
					}
					if (oldCreator) {
						if (oldCreator.ref.equals(newCreator) || (oldCreator.ref.libraryID != newCreator.libraryID)) {
							if (oldCreator.creatorTypeID == creatorTypeID
								&& (isMulti || oldCreator.multi.mainLang() === langTag)) {
								Zotero.debug("Creator " + oldCreator.ref.id + " hasn't changed");
							}
							// Just change creatorTypeID
							else {
								if (isMulti) {
									this.item.setCreator(index, oldCreator.ref, creatorTypeID, langTag);
								} else {
									this.item.setCreator(index, oldCreator.ref, creatorTypeID, langTag, true);
								}
								if (this.saveOnEdit) {
									this.item.save();
								}
							}
							Zotero.DB.commitTransaction();
							return;
						}
						
						oldCreator = oldCreator.ref;
					}
					
					var creator;
					var creatorID;

					if (oldCreator) {
						var numLinkedItems = oldCreator.countLinkedItems();
						// Creator is linked only to the current item
						if (numLinkedItems == 1) {
							if (newLinkedCreators.length) {
								// Use the first creator found with this data
								// TODO: support choosing among options
								creatorID = newLinkedCreators[0];
								creator = Zotero.Creators.get(creatorID);
							}
							else {
								oldCreator.setFields(fields);
								//creatorID = oldCreator.save();
								creator = oldCreator;
							}
						}
						// Creator is linked to multiple items with changeGlobally off
						else if (!changeGlobally) {
							if (newLinkedCreators.length) {
								// Use the first creator found with this data
								// TODO: support choosing among options
								creatorID = newLinkedCreators[0];
								creator = Zotero.Creators.get(creatorID);
							}
							else {
								//creatorID = newCreator.save();
								creator = newCreator;
							}
						}
						// Creator is linked to multiple items with changeGlobally on
						else {
							throw ('changeGlobally unimplemented');
							if (newLinkedCreators.length) {
								// Use the first creator found with this data
								// TODO: support choosing among options
								creatorID = newLinkedCreators[0];
								
								// TODO: switch all linked items to this creator
							}
							else {
								creatorID = newCreator.save();
								
								// TODO: switch all linked items to new creatorID
							}
						}
					}
					// No existing creator
					else {
						if (newLinkedCreators.length && !isMulti) {
							creatorID = newLinkedCreators[0];
							creator = Zotero.Creators.get(creatorID);
						}
						else {
							//creatorID = newCreator.save();
							creator = newCreator;
						}
					}
					
					this.item.setCreator(index, creator, creatorTypeID, langTag, !isMulti);
					if (this.saveOnEdit) {
						try {
							this.item.save();
						}
						catch (e) {
							// DEBUG: Errors aren't being logged in Fx3.1b4pre without this
							Zotero.debug(e);
							Components.utils.reportError(e);
							throw (e);
						}
					}
					
					Zotero.DB.commitTransaction();
				
				}
				catch (e) {
					Zotero.debug(e);
					Components.utils.reportError(e);
					throw (e);
				}
				]]>
				</body>
			</method>
			
			
			<method name="swapNames">
				<body><![CDATA[
					var row = Zotero.getAncestorByTagName(document.popupNode, 'row');
					var typeBox = row.getElementsByAttribute('popup', 'creator-type-menu')[0];
					var creatorIndex = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);
					var fields = this.getCreatorFields(row);
					var lastName = fields.lastName;
					var firstName = fields.firstName;
					fields.lastName = firstName;
					fields.firstName = lastName;
					this.modifyCreator(creatorIndex, fields);
					this.item.save();
				]]></body>
			</method>
			
			<method name="moveCreator">
				<parameter name="index"/>
				<parameter name="moveUp"/>
				<body>
				<![CDATA[
					if (index == 0 && moveUp) {
						Zotero.debug("Can't move up creator 0");
						return;
					}
					else if (index + 1 == this.item.numCreators() && !moveUp) {
						Zotero.debug("Can't move down last creator");
						return;
					}
					
					var newIndex = moveUp ? index - 1 : index + 1;
					this.item.swapCreators(index,newIndex);
					if (this.saveOnEdit) {
						this.item.save();
					}
				]]>
				</body>
			</method>
			
			
			<method name="_updateAutoCompleteParams">
				<parameter name="row"/>
				<parameter name="changedParams"/>
				<body>
				<![CDATA[
					var textboxes = row.getElementsByTagName('textbox');
					if (textboxes.length) {
						var t = textboxes[0];
						var params = JSON.parse(t.getAttribute('autocompletesearchparam'));
						for (var param in changedParams) {
							params[param] = changedParams[param];
						}
						t.setAttribute('autocompletesearchparam', JSON.stringify(params));
					}
				]]>
				</body>
			</method>
			
			<!--
			/*
			function modifyCreatorByID(index, creatorID, creatorTypeID) {
				throw ('Unimplemented');
				var oldCreator = _itemBeingEdited.getCreator(index);
				if (creator) {
					oldCreator = creator.ref;
					var oldCreatorID = oldCreator.creatorID;
				}
				
				Zotero.debug("Old creatorID is " + oldCreatorID);
				
				_itemBeingEdited.setCreator(index, firstName, lastName, typeID, fieldMode);
				_itemBeingEdited.save();
			}
			*/
			-->
			
			
			<method name="focusFirstField">
				<body>
				<![CDATA[
					this._focusNextField(this._dynamicFields, 0, false);
				]]>
				</body>
			</method>
			
			
			<!-- 
				Advance the field focus forward or backward
				
				Note: We're basically replicating the built-in tabindex functionality,
				which doesn't work well with the weird label/textbox stuff we're doing.
				(The textbox being tabbed away from is deleted before the blur()
				completes, so it doesn't know where it's supposed to go next.)
			-->
			<method name="_focusNextField">
				<parameter name="box"/>
				<parameter name="tabindex"/>
				<parameter name="back"/>
				<body>
				<![CDATA[
					tabindex = parseInt(tabindex);
					
					if (back)
					{
						switch (tabindex)
						{
							case 1:
								//Zotero.debug('At beginning');
								document.getElementById('item-type-menu').focus();
								return false;
							
							case this._tabIndexMinCreators:
								var nextIndex = this._tabIndexMaxPrefields; // Title fields
								break;
							
							case this._tabIndexMinFields:
								// No creators
								if (this._tabIndexMaxCreators == 0) {
									var nextIndex = 1; // Title field
								}
								else {
									var nextIndex = this._tabIndexMaxCreators;
								}
								break;
							
							default:
								var nextIndex = tabindex - 1;
						}
					}
					else
					{
						switch (tabindex)
						{
							case this._tabIndexMaxPrefields:
								var nextIndex = this._tabIndexMinCreators;
								break;
							
							case this._tabIndexMaxCreators:
								var nextIndex = this._tabIndexMinFields;
								break;
							
							case this._tabIndexMaxFields:
								//Zotero.debug('At end');
								return false;
							
							default:
								var nextIndex = tabindex + 1;
						}
					}
					
					Zotero.debug('Looking for tabindex ' + nextIndex, 4);
					
					var next = box.getElementsByAttribute('ztabindex', nextIndex);
					if (!next[0])
					{
						Zotero.debug("Next field not found");
						return this._focusNextField(box, nextIndex, back);
					}
					
					next[0].click();
					
					// DEBUG: next[0] is always equal to the target element,
					// but for some reason it's necessary to scroll to the next
					// element when moving forward for the target element to
					// be fully in view
					if (!back && next[0].parentNode.nextSibling) {
						var visElem = next[0].parentNode.nextSibling;
					}
					else {
						var visElem = next[0];
					}
					this.ensureElementIsVisible(visElem);
					
					return true;
				]]>
				</body>
			</method>
			
			
			<method name="blurOpenField">
				<body>
				<![CDATA[
					var textboxes = document.getAnonymousNodes(this)[0].getElementsByTagName('textbox');
					if (textboxes && textboxes.length) {
						textboxes[0].inputField.blur();
					}
				]]>
				</body>
			</method>
			
			
			<!--
				Available handlers:
				
				  - 'itemtypechange'
				
				Note: 'this' in the function will be bound to the item box.
			-->
			<method name="addHandler">
				<parameter name="eventName"/>
				<parameter name="func"/>
				<body>
				<![CDATA[
					if (!this.eventHandlers[eventName]) {
						this.eventHandlers[eventName] = [];
					}
					this.eventHandlers[eventName].push(func);
				]]>
				</body>
			</method>
			
			<method name="removeHandler">
				<parameter name="eventName"/>
				<parameter name="func"/>
				<body>
				<![CDATA[
					if (!this.eventHandlers[eventName]) {
						return;
					}
					var pos = this.eventHandlers[eventName].indexOf(func);
					if (pos != -1) {
						this.eventHandlers[eventName].splice(pos, 1);
					}
				]]>
				</body>
			</method>
			
			
			<method name="_id">
				<parameter name="id"/>
				<body>
				<![CDATA[
					return document.getAnonymousNodes(this)[0].getElementsByAttribute('id', id)[0];
				]]>
				</body>
			</method>

			<method name="setJurisdictionKey">
			  <parameter name="key"/>
			  <parameter name="node"/>
			  <body>
				<![CDATA[
					var jurisdictionDefaultNode = document.getElementById('jurisdiction-default');
					if (key && jurisdictionDefaultNode) {
						if (key && key == Zotero.Prefs.get("import.jurisdictionDefault")) {
							jurisdictionDefaultNode.setAttribute("checked",true);
						} else {
							jurisdictionDefaultNode.setAttribute("checked",false);
						}
					}
					this.item.setField("jurisdiction",key);
					node.setAttribute("style","");
					this.item.save();
				]]>
			  </body>
			</method>

		</implementation>
		
		<content>
			<scrollbox id="item-box" flex="1" orient="vertical"
				 	xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
				<popupset>
					<menupopup id="creator-type-menu" position="after_start"
						onpopupshowing="var typeBox = document.popupNode.localName == 'hbox' ? document.popupNode : document.popupNode.parentNode;
								var index = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);
								
								var item = document.getBindingParent(this).item;
								var exists = item.hasCreatorAt(index);
								var moreCreators = item.numCreators() > index + 1;
								
								var hideMoveUp = !exists || index == 0;
								var hideMoveDown = !exists || !moreCreators;
								var hideMoveSep = hideMoveUp &amp;&amp; hideMoveDown;
								
								document.getElementById('zotero-creator-move-sep').setAttribute('hidden', hideMoveSep);
								document.getElementById('zotero-creator-move-up').setAttribute('hidden', hideMoveUp);
								document.getElementById('zotero-creator-move-down').setAttribute('hidden', hideMoveDown);"
						oncommand="var typeBox = document.popupNode.localName == 'hbox' ? document.popupNode : document.popupNode.parentNode;
							var index = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);
							
							var itemBox = document.getBindingParent(this);
							
							if (event.explicitOriginalTarget.className == 'zotero-creator-move') {
								var up = event.explicitOriginalTarget.id == 'zotero-creator-move-up';
								itemBox.moveCreator(index, up);
								return;
							}
							
							var typeID = event.explicitOriginalTarget.getAttribute('typeid');
							var row = typeBox.parentNode;
							var fields = itemBox.getCreatorFields(row);
							fields.creatorTypeID = typeID;
							typeBox.getElementsByTagName('label')[0].setAttribute(
								'value',
								Zotero.getString(
									'creatorTypes.' + Zotero.CreatorTypes.getName(typeID)
								) + ':'
							);
							typeBox.setAttribute('typeid', typeID);
							
							/* If a creator textbox is already open, we need to
							change its autocomplete parameters so that it
							completes on a creator with a different creator type */
							var changedParams = {
								creatorTypeID: typeID
							};
							itemBox._updateAutoCompleteParams(row, changedParams);

							itemBox.modifyCreator(index, fields);"/>
					<menupopup id="zotero-field-transform-menu">
						<menu label="&zotero.item.textTransform;">
							<menupopup>
								<menuitem label="&zotero.item.textTransform.titlecase;" class="menuitem-non-iconic"
									oncommand="document.getBindingParent(this).textTransform(document.popupNode, 'title')"/>
								<menuitem label="&zotero.item.textTransform.sentencecase;" class="menuitem-non-iconic"
									oncommand="document.getBindingParent(this).textTransform(document.popupNode, 'sentence')"/>
							</menupopup>
						</menu>
					</menupopup>
					<menupopup id="zotero-creator-transform-menu"
						onpopupshowing="var row = Zotero.getAncestorByTagName(document.popupNode, 'row');
							var typeBox = row.getElementsByAttribute('popup', 'creator-type-menu')[0];
							var index = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);
							var item = document.getBindingParent(this).item;
							var exists = item.hasCreatorAt(index);
							if (exists) {
								var fieldMode = item.getCreator(index).ref.fieldMode;
							}
							var hideTransforms = !exists || !!fieldMode;
							return !hideTransforms;">
						<menuitem label="&zotero.item.creatorTransform.nameSwap;"
							oncommand="document.getBindingParent(this).swapNames();"/>
					</menupopup>
					<menupopup id="mlz-language-menu"
						onpopupshowing="
						/* Abort if no languages available */
						var item = document.getBindingParent(this).item;
						if (!Zotero.CachedLanguages.getLanguageList(item)) {
							return false;
						}
						/* Popup Node */
						var labelNode = document.popupNode;
						if ((labelNode.localName != 'hbox' &amp;&amp; labelNode.localName != 'label') || labelNode.parentNode.classList.contains('creator-type-label')) {
							labelNode = document.popupNode.parentNode;
						}
						/* Abort if not multilingual-ize-able field */
						if (!labelNode.classList.contains('zotero-alien-clicky') &amp;&amp; !labelNode.classList.contains('creator-type-label')) {
							return false;
						}
						/* Get field type */
						var isMulti = false;
						var fieldType = 'field';
						if (labelNode.classList.contains('creator-type-label')) {
							fieldType = 'creator';
							
						}
						/* Get field name or creator index value */
						var fieldName = null;
						creatorIndex = null;
						if (fieldType == 'field') {
							fieldName = labelNode.getAttribute('fieldname');
						} else if (fieldType == 'creator') {
							var creatorIndex = parseInt(labelNode.getAttribute('fieldname').split('-')[1],10);
						}
						var rowsNode = Zotero.getAncestorByTagName(labelNode,'rows');
						if (rowsNode.classList.contains('multi')) {
							isMulti = true;
							fieldType += 'Multi';
						}
						try {
						/* Get field value */
						if (fieldType === 'field' || fieldType === 'fieldMulti') {
							var mainFieldValue = item.getField(fieldName, true);
						} else {
							var mainFieldValue = item.getCreator(creatorIndex);
						}
						/* Get row language in use */
						var rowLang = labelNode.getAttribute('zlang');
						var menu = this;
						for (var i=0,ilen=menu.childNodes.length;i&lt;ilen;i+=1) {
							menu.removeChild(menu.childNodes[0]);
						};
						/* SET LANGUAGE */
						function setLanguageMenu (menuName,langLst,menuType,functionType,fieldValue) {
							if (!langLst.length) {
								return;
							}
							var node = document.createElement('label');
							node.setAttribute('value', menuName);
							node.setAttribute('style', 'font-weight:bold;padding:0 0.5em 0 0.5em;');
							menu.appendChild(node);
							for (var i=0,ilen=langLst.length;i&lt;ilen;i+=1) {
								var nickname = langLst[i].nickname;
								var tag = langLst[i].tag;
								var itemNode = document.createElement('menuitem');
								itemNode.setAttribute('label',nickname);
								itemNode.setAttribute('value',tag);
								itemNode.setAttribute('type',menuType);
								if ('radio' === menuType) {
									itemNode.setAttribute('name','set-language');
									if (tag == rowLang) {
										itemNode.setAttribute('checked', true);
									}
									if (fieldType === 'field' || fieldType === 'fieldMulti') {
										if (!item.multi.hasLang(tag, fieldName)) {
											itemNode.setAttribute('style', 'font-style:italic;');
										}
									} else {
										if (!mainFieldValue.multi.hasLang(tag)) {
											itemNode.setAttribute('style', 'font-style:italic;');
										}
									}
								}
								menu.appendChild(itemNode);
								var func = function(labelNode,tag,fieldValue) {
									return function () {
										document.getBindingParent(this)[functionType + 'LangMenuFunc'](labelNode,tag,fieldValue);
									};
								};
								var menuFunc = func(labelNode,tag,fieldValue);
								itemNode.addEventListener('click',menuFunc);
							};
						}
						if (fieldType === 'field' || fieldType === 'fieldMulti') {
							var languageList = [];
							var variantList = [];
							if (!isMulti) {
								if (mainFieldValue) {
									variantList = Zotero.CachedLanguages.getVariantList(item, fieldName, true);
									setLanguageMenu('Add Variant', variantList,null,'add',mainFieldValue);
								}
								languageList = Zotero.CachedLanguages.getLanguageList(item, fieldName, false);
								setLanguageMenu('Set Main Language', languageList,'radio','main',mainFieldValue);
							} else {
								languageList = Zotero.CachedLanguages.getVariantList(item, fieldName, true);
								var multiFieldValue = item.getField(fieldName, null, null, rowLang);
								setLanguageMenu('Change Language',languageList,'radio','change',multiFieldValue);
							}
							if (!languageList.length &amp;&amp; !variantList.length) {
								return false;
							}
						}
						if (fieldType === 'creator' || fieldType === 'creatorMulti') {
							var languageList = [];
							var variantList = [];
							if (!isMulti) {
								if (mainFieldValue) {
									variantList = Zotero.CachedLanguages.getVariantList(item, creatorIndex, true);
									setLanguageMenu('Add Variant', variantList,null,'creatorAdd',mainFieldValue);
								}
								languageList = Zotero.CachedLanguages.getLanguageList(item, creatorIndex, false);
								setLanguageMenu('Set Main Language', languageList,'radio','creatorMain',mainFieldValue);
							} else {
								languageList = Zotero.CachedLanguages.getVariantList(item, creatorIndex, true);
								setLanguageMenu('Change Language',languageList,'radio','creatorChange',mainFieldValue);
							}
							if (!languageList.length &amp;&amp; !variantList.length) {
								return false;
							}
						}
						} catch(e) {
							Zotero.debug('XXX OOPS: '+e);
						}
						return true;">
						<menuitem label="Bogus Menu"
							oncommand="alert('Boo!');"/>
					</menupopup>
					<zoteroguidancepanel id="zotero-author-guidance" about="authorMenu" position="after_end" x="-25"/>
				</popupset>
				<grid flex="1">
					<columns>
						<column/>
						<column flex="1"/>
					</columns>
					<rows id="dynamic-fields" flex="1">
						<row class="zotero-item-first-row">
							<label value="&zotero.items.itemType;:"/>
							<menulist class="zotero-clicky" id="item-type-menu" oncommand="document.getBindingParent(this).changeTypeTo(this.value, this)" flex="1"
								onfocus="document.getBindingParent(this).ensureElementIsVisible(this)"
								onkeypress="if (event.keyCode == event.DOM_VK_TAB) { document.getBindingParent(this).itemTypeMenuTab(event); }">
								<menupopup/>
							</menulist>
						</row>
					</rows>
				</grid>
			</scrollbox>
		</content>
	</binding>
</bindings>
